<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter Models Dashboard</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
const { useState, useEffect, useMemo } = React;

// Simple SVG icon components (replacing lucide-react)
const Search = ({ className = "w-5 h-5" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
  </svg>
);
const ChevronDown = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <polyline points="6 9 12 15 18 9"/>
  </svg>
);
const ChevronUp = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <polyline points="18 15 12 9 6 15"/>
  </svg>
);
const Brain = ({ className = "w-3 h-3" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/>
    <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/>
  </svg>
);
const CheckCircle = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>
  </svg>
);
const XCircle = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/>
  </svg>
);
const AlertCircle = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/>
  </svg>
);
const Clock = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/>
  </svg>
);
const Zap = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
  </svg>
);
const Download = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
  </svg>
);
const Save = ({ className = "w-3 h-3" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/>
  </svg>
);
const Star = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <polygon points="12 2 15 8.5 22 9.3 17 14 18.5 21 12 17.8 5.5 21 7 14 2 9.3 9 8.5 12 2"/>
  </svg>
);
const StarFilled = ({ className = "w-4 h-4" }) => (
  <svg className={className} viewBox="0 0 24 24">
    <path d="M12 2l3 6.5 7 .8-5 4.7L18.5 21 12 17.8 5.5 21 7 14 2 9.3l7-.8L12 2z" fill="currentColor" />
  </svg>
);
const RefreshCw = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
  </svg>
);
const Copy = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
  </svg>
);
const Info = ({ className = "w-4 h-4" }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/>
  </svg>
);

// Minimal Markdown link renderer: turns [text](https://...) and <https://...> into clickable anchors
const renderMarkdownLinks = (text) => {
  if (!text || typeof text !== 'string') return text;
  const nodes = [];
  const regex = /\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)|<((?:https?:\/\/)[^>]+)>|(https?:\/\/[^\s)]+)(?![^<]*>)/g;
  let lastIndex = 0;
  let match;
  let key = 0;
  while ((match = regex.exec(text)) !== null) {
    const [full, label, url1, url2, url3] = match;
    const url = url1 || url2 || url3;
    const linkText = label || url;
    // text before the match
    if (match.index > lastIndex) {
      nodes.push(text.slice(lastIndex, match.index));
    }
    nodes.push(
      <a key={`mdlink-${key++}`} href={url} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline">
        {linkText}
      </a>
    );
    lastIndex = regex.lastIndex;
  }
  if (lastIndex < text.length) {
    nodes.push(text.slice(lastIndex));
  }
  return nodes;
};

// Benchmark descriptions for tooltips
const BENCHMARK_DESCRIPTIONS = {
  // General intelligence
  'Intelligence Index': 'Overall intelligence score combining multiple reasoning, knowledge, and problem-solving benchmarks',
  'Estimated Intelligence Index': 'Estimated intelligence score provided when measured Intelligence Index is unavailable',
  'Intelligence Index per 1M Output Tokens': 'Intelligence Index divided by output token price per 1M; higher means more intelligence per dollar',
  'Intelligence Index Is Estimated': 'True if Intelligence Index is inferred from an estimate rather than measured directly',
  // Core benchmarks
  'GPQA': 'Graduate-level Google-Proof Q&A reasoning benchmark',
  'HLE': 'Hellaswag-like evaluation of commonsense reasoning and inference (HLE)',
  'HumanEval': 'Code generation ability measured by Python function unit tests',
  'Math 500': 'Math 500 benchmark measuring mathematical problem solving',
  'MMLU Pro': 'Massive Multitask Language Understanding Pro across diverse academic subjects',
  'MMMU Pro': 'Multimodal Multitask Understanding Pro benchmark',
  'IFBench': 'Instruction Following Benchmark testing adherence and accuracy',
  'SciCode': 'Scientific code writing and computational science problems',
  'LiveCodeBench': 'Coding on real-world, post-cutoff problems',
  'Math Index': 'Composite of mathematical reasoning performance',
  'Coding Index': 'Composite of coding performance across tasks and languages',
  'Agentic Index': 'Ability to plan, reason, and execute multi-step tasks autonomously',
  // AIME / Olympiad
  'AIME': 'American Invitational Mathematics Examination style reasoning (normalized)',
  'AIME 25': 'AIMEâ€‘25 variant, typically harder subset of AIME-style questions',
  'Lab-Claimed AIME': 'Vendor-reported AIME results (unverified lab claims)',
  'Lab-Claimed Math 500': 'Vendor-reported Math 500 results (unverified lab claims)',
  // Reasoning / LCR
  'LCR': 'Long Context Reasoning metric',
  'TAU-2': 'Reasoning correlation metric tau-2',
  // Specialized leaderboards
  'TerminalBench Hard': 'Hard split of terminal/agentic reasoning tasks',
  'Multilingual AA': 'Aggregate multilingual accuracy score from AA',
  // Chart axis labels (score variants)
  'GPQA Score': 'Graduate-level Google-Proof Q&A reasoning benchmark',
  'HumanEval Score': 'Code generation ability measured by Python function unit tests',
  'MMLU Pro Score': 'Massive Multitask Language Understanding Pro',
  'LiveCodeBench Score': 'Coding on real-world, post-cutoff problems',
  'SciCode Score': 'Scientific code writing and computational science problems',
  'HLE Score': 'Hellaswag-like evaluation of commonsense reasoning and inference (HLE)',
  'Math 500 Score': 'Math 500 benchmark measuring mathematical problem solving',
  'MMMU Pro Score': 'Multimodal Multitask Understanding Pro benchmark',
  'IFBench Score': 'Instruction Following Benchmark testing adherence and accuracy',
  'AIME Score': 'American Invitational Mathematics Examination style reasoning (normalized)',
  'AIME 25 Score': 'AIMEâ€‘25 variant, typically harder subset of AIME-style questions'
};

// Initial cross-reference mapping from Set 1 (aliases) to Set 2 (OpenRouter vendor/id)
// These seed values come from the table you provided. Users can override them in the Mapping tab.
const INITIAL_AA_MAPPING = [
  { alias: 'Apriel-v1.5-15B-Thinker', targetId: null, certainty: '-' },
  { alias: 'Aya Expanse 32B', targetId: null, certainty: '-' },
  { alias: 'Aya Expanse 8B', targetId: null, certainty: '-' },
  { alias: 'Claude 4.1 Opus', targetId: 'anthropic/claude-4.1-opus', certainty: 'High' },
  { alias: 'Claude 4.5 Haiku', targetId: 'anthropic/claude-haiku-4.5', certainty: 'High' },
  { alias: 'Claude 4.5 Sonnet', targetId: 'anthropic/claude-4.5-sonnet', certainty: 'High' },
  { alias: 'Codestral (Jan)', targetId: 'mistralai/codestral-2501', certainty: 'High' },
  { alias: 'Command A', targetId: 'cohere/command-a', certainty: 'High' },
  { alias: 'DeepHermes 3 - Llama-3.1 8B', targetId: 'nousresearch/deephermes-3-llama-3-8b-preview', certainty: 'High' },
  { alias: 'DeepHermes 3 - Mistral 24B', targetId: 'nousresearch/deephermes-3-mistral-24b-preview', certainty: 'High' },
  { alias: 'DeepSeek R1 0528', targetId: 'deepseek/deepseek-r1-0528', certainty: 'High' },
  { alias: 'DeepSeek R1 0528 Qwen3 8B', targetId: 'deepseek/deepseek-r1-0528-qwen3-8b', certainty: 'High' },
  { alias: 'DeepSeek R1 Distill Llama 70B', targetId: 'deepseek/deepseek-r1-distill-llama-70b', certainty: 'High' },
  { alias: 'DeepSeek V3.1 Terminus', targetId: 'deepseek/deepseek-v3.1-terminus', certainty: 'High' },
  { alias: 'DeepSeek V3.2 Exp', targetId: 'deepseek/deepseek-v3.2-exp', certainty: 'High' },
  { alias: 'Devstral Medium', targetId: 'mistralai/devstral-medium', certainty: 'High' },
  { alias: 'Devstral Small', targetId: 'mistralai/devstral-small', certainty: 'High' },
  { alias: 'ERNIE 4.5 300B A47B', targetId: 'baidu/ernie-4.5-300b-a47b', certainty: 'High' },
  { alias: 'EXAONE 4.0 32B', targetId: null, certainty: '-' },
  { alias: 'Exaone 4.0 1.2B', targetId: null, certainty: '-' },
  { alias: 'Gemma 3 12B', targetId: 'google/gemma-3-12b-it', certainty: 'High' },
  { alias: 'Gemma 3 1B', targetId: null, certainty: '-' },
  { alias: 'Gemma 3 270M', targetId: null, certainty: '-' },
  { alias: 'Gemma 3 27B', targetId: 'google/gemma-3-27b-it', certainty: 'High' },
  { alias: 'Gemma 3 4B', targetId: 'google/gemma-3-4b-it', certainty: 'High' },
  { alias: 'Gemma 3n E2B', targetId: 'google/gemma-3n-e2b-it:free', certainty: 'High' },
  { alias: 'Gemma 3n E4B', targetId: 'google/gemma-3n-e4b-it', certainty: 'High' },
  { alias: 'Gemini 2.5 Flash (Sep)', targetId: 'google/gemini-2.5-flash-preview-09-2025', certainty: 'High' },
  { alias: 'Gemini 2.5 Flash-Lite (Sep)', targetId: 'google/gemini-2.5-flash-lite-preview-09-2025', certainty: 'High' },
  { alias: 'Gemini 2.5 Pro', targetId: 'google/gemini-2.5-pro', certainty: 'High' },
  { alias: 'GLM-4.5-Air', targetId: 'z-ai/glm-4.5-air', certainty: 'High' },
  { alias: 'GLM-4.5V', targetId: 'z-ai/glm-4.5v', certainty: 'High' },
  { alias: 'GLM-4.6', targetId: 'z-ai/glm-4.6', certainty: 'High' },
  { alias: 'GPT-5 (ChatGPT)', targetId: 'openai/gpt-5-chat', certainty: 'High' },
  { alias: 'GPT-5 (high)', targetId: 'openai/gpt-5', certainty: 'High' },
  { alias: 'GPT-5 (low)', targetId: 'openai/gpt-5', certainty: 'High' },
  { alias: 'GPT-5 (medium)', targetId: 'openai/gpt-5', certainty: 'High' },
  { alias: 'GPT-5 (minimal)', targetId: 'openai/gpt-5', certainty: 'High' },
  { alias: 'GPT-5 Codex (high)', targetId: 'openai/gpt-5-codex', certainty: 'High' },
  { alias: 'GPT-5 mini (high)', targetId: 'openai/gpt-5-mini', certainty: 'High' },
  { alias: 'GPT-5 mini (medium)', targetId: 'openai/gpt-5-mini', certainty: 'High' },
  { alias: 'GPT-5 mini (minimal)', targetId: 'openai/gpt-5-mini', certainty: 'High' },
  { alias: 'GPT-5 nano (high)', targetId: 'openai/gpt-5-nano', certainty: 'High' },
  { alias: 'GPT-5 nano (medium)', targetId: 'openai/gpt-5-nano', certainty: 'High' },
  { alias: 'GPT-5 nano (minimal)', targetId: 'openai/gpt-5-nano', certainty: 'High' },
  { alias: 'Granite 4.0 H Small', targetId: null, certainty: '-' },
  { alias: 'Granite 4.0 Micro', targetId: 'ibm-granite/granite-4.0-h-micro', certainty: 'High' },
  { alias: 'Grok 3 mini Reasoning (high)', targetId: 'x-ai/grok-3-mini', certainty: 'High' },
  { alias: 'Grok 4', targetId: null, certainty: '-' },
  { alias: 'Grok 4 Fast', targetId: 'x-ai/grok-4-fast', certainty: 'High' },
  { alias: 'Grok Code Fast 1', targetId: 'x-ai/grok-code-fast-1', certainty: 'High' },
  { alias: 'Hermes 4 405B', targetId: 'nousresearch/hermes-4-405b', certainty: 'High' },
  { alias: 'Hermes 4 70B', targetId: 'nousresearch/hermes-4-70b', certainty: 'High' },
  { alias: 'Jamba 1.7 Large', targetId: 'ai21/jamba-large-1.7', certainty: 'High' },
  { alias: 'Jamba 1.7 Mini', targetId: 'ai21/jamba-mini-1.7', certainty: 'High' },
  { alias: 'Jamba Reasoning 3B', targetId: null, certainty: '-' },
  { alias: 'Kimi K2 0905', targetId: 'moonshotai/kimi-k2-0905', certainty: 'High' },
  { alias: 'LFM2 1.2B', targetId: null, certainty: '-' },
  { alias: 'LFM2 2.6B', targetId: 'liquid/lfm-2.2-6b', certainty: 'High' },
  { alias: 'LFM2 8B A1B', targetId: 'liquid/lfm2-8b-a1b', certainty: 'High' },
  { alias: 'Llama 3.1 405B', targetId: 'meta-llama/llama-3.1-405b', certainty: 'High' },
  { alias: 'Llama 3.1 Nemotron 70B', targetId: 'nvidia/llama-3.1-nemotron-70b-instruct', certainty: 'High' },
  { alias: 'Llama 3.1 Nemotron Nano 4B v1.1', targetId: null, certainty: '-' },
  { alias: 'Llama 3.2 11B (Vision)', targetId: 'meta-llama/llama-3.2-11b-vision-instruct', certainty: 'High' },
  { alias: 'Llama 3.2 90B (Vision)', targetId: 'meta-llama/llama-3.2-90b-vision-instruct', certainty: 'High' },
  { alias: 'Llama 3.3 70B', targetId: 'meta-llama/llama-3.3-70b-instruct', certainty: 'High' },
  { alias: 'Llama 3.3 Nemotron Super 49B', targetId: 'nvidia/llama-3.3-nemotron-super-49b-v1.5', certainty: 'High' },
  { alias: 'Llama 4 Maverick', targetId: 'meta-llama/llama-4-maverick', certainty: 'High' },
  { alias: 'Llama 4 Scout', targetId: 'meta-llama/llama-4-scout', certainty: 'High' },
  { alias: 'Llama Nemotron Super 49B v1.5', targetId: 'nvidia/llama-3.3-nemotron-super-49b-v1.5', certainty: 'High' },
  { alias: 'Llama Nemotron Ultra', targetId: 'nvidia/llama-3.1-nemotron-ultra-253b-v1', certainty: 'High' },
  { alias: 'Magistral Medium 1.2', targetId: 'mistralai/magistral-medium-1.2', certainty: 'High' },
  { alias: 'Magistral Small 1.2', targetId: 'mistralai/magistral-small-1.2', certainty: 'High' },
  { alias: 'MiniMax M1 40k', targetId: 'minimax/minimax-m1', certainty: 'High' },
  { alias: 'MiniMax M1 80k', targetId: 'minimax/minimax-m1', certainty: 'High' },
  { alias: 'MiniMax-M2', targetId: 'minimax/minimax-m2:free', certainty: 'High' },
  { alias: 'MiniMax-Text-01', targetId: 'minimax/minimax-01', certainty: 'High' },
  { alias: 'Ministral 3B', targetId: 'mistralai/ministral-3b', certainty: 'High' },
  { alias: 'Ministral 8B', targetId: 'mistralai/ministral-8b', certainty: 'High' },
  { alias: 'Mistral Medium 3.1', targetId: 'mistralai/mistral-medium-3.1', certainty: 'High' },
  { alias: 'Mistral Small 3.2', targetId: 'mistralai/mistral-small-3.2-24b-instruct', certainty: 'High' },
  { alias: 'Nova Lite', targetId: 'amazon/nova-lite-v1', certainty: 'High' },
  { alias: 'Nova Micro', targetId: 'amazon/nova-micro-v1', certainty: 'High' },
  { alias: 'Nova Premier', targetId: null, certainty: '-' },
  { alias: 'Nova Pro', targetId: 'amazon/nova-pro-v1', certainty: 'High' },
  { alias: 'NVIDIA Nemotron Nano 9B V2', targetId: 'nvidia/nemotron-nano-9b-v2', certainty: 'High' },
  { alias: 'Phi-4', targetId: 'microsoft/phi-4', certainty: 'High' },
  { alias: 'Phi-4 Mini', targetId: null, certainty: '-' },
  { alias: 'Phi-4 Multimodal', targetId: 'microsoft/phi-4-multimodal-instruct', certainty: 'High' },
  { alias: 'Qwen3 235B A22B 2507', targetId: 'qwen/qwen3-235b-a22b-2507', certainty: 'High' },
  { alias: 'Qwen3 235B 2507', targetId: 'qwen/qwen3-235b-a22b-2507', certainty: 'High' },
  { alias: 'Qwen3 30B A3B 2507', targetId: 'qwen/qwen3-30b-a3b-instruct-2507', certainty: 'High' },
  { alias: 'Qwen3 4B 2507', targetId: 'qwen/qwen3-4b:free', certainty: 'Medium' },
  { alias: 'Qwen3 Coder 30B A3B', targetId: 'qwen/qwen3-coder-30b-a3b-instruct', certainty: 'High' },
  { alias: 'Qwen3 Coder 480B', targetId: 'qwen/qwen3-coder', certainty: 'High' },
  { alias: 'Qwen3 Max', targetId: 'qwen/qwen3-max', certainty: 'High' },
  { alias: 'Qwen3 Next 80B A3B', targetId: 'qwen/qwen3-next-80b-a3b-instruct', certainty: 'High' },
  { alias: 'Qwen3 Omni 30B A3B', targetId: null, certainty: '-' },
  { alias: 'Qwen3 VL 30B A3B', targetId: 'qwen/qwen3-vl-30b-a3b-instruct', certainty: 'High' },
  { alias: 'Qwen3 VL 4B', targetId: null, certainty: '-' },
  { alias: 'Qwen3 VL 8B', targetId: 'qwen/qwen3-vl-8b-instruct', certainty: 'High' },
  { alias: 'R1 1776', targetId: null, certainty: '-' },
  { alias: 'Reka Flash 3', targetId: null, certainty: '-' },
  { alias: 'Seed-OSS-36B-Instruct', targetId: null, certainty: '-' },
  { alias: 'Solar Pro 2', targetId: null, certainty: '-' },
  { alias: 'gpt-oss-120B (high)', targetId: 'openai/gpt-oss-120b', certainty: 'High' },
  { alias: 'gpt-oss-20B (high)', targetId: 'openai/gpt-oss-20b', certainty: 'High' },
  { alias: 'o3', targetId: 'openai/o3', certainty: 'High' },
];


const ModelsDashboard = () => {
  const [models, setModels] = useState([]);
  const [detailedStats, setDetailedStats] = useState({});
  const [loading, setLoading] = useState(true);
  const [loadingStats, setLoadingStats] = useState(false);
  const [statsProgress, setStatsProgress] = useState({ current: 0, total: 0 });
  const [lastUpdated, setLastUpdated] = useState(null);
  const [search, setSearch] = useState('');
  const [sortBy, setSortBy] = useState('name');
  const [sortDir, setSortDir] = useState('asc');
  const [filterModality, setFilterModality] = useState('all');
  const [filterReasoning, setFilterReasoning] = useState('all');
  const [filterFree, setFilterFree] = useState('all');
  const [filterFeatures, setFilterFeatures] = useState({
    tools: false,
    json: false,
    reasoning: false
  });
  const [minContext, setMinContext] = useState(0);
  const [maxPromptPrice, setMaxPromptPrice] = useState(5); // per 1M tokens - default to common range
  const [maxCompletionPrice, setMaxCompletionPrice] = useState(10); // per 1M tokens - default to common range
  const [showFullPriceRange, setShowFullPriceRange] = useState(false); // toggle for full range vs common range
  const [expandedRow, setExpandedRow] = useState(null);
  const [hasAttemptedAutoLoad, setHasAttemptedAutoLoad] = useState(false);
  const [activeTab, setActiveTab] = useState('table');
  const [plotXAxis, setPlotXAxis] = useState('latency');
  const [plotYAxis, setPlotYAxis] = useState('throughput');
  // Heatmap selections
  const [heatmapXAxis, setHeatmapXAxis] = useState('prompt_price');
  const [heatmapYAxis, setHeatmapYAxis] = useState('latency');
  const [heatmapColorAxis, setHeatmapColorAxis] = useState('coding_index');
  // Artificial Analysis leaderboard
  const [aaIndexMap, setAaIndexMap] = useState({});
  const [aaHeaders, setAaHeaders] = useState([]);
  const [aaRows, setAaRows] = useState([]);
  const [aaLoading, setAaLoading] = useState(false);
  const [aaError, setAaError] = useState(null);
  const [visibleAaCols, setVisibleAaCols] = useState([]);
  // Favorites
  const FAVORITES_STORAGE_KEY = 'favorite_models_v1';
  const [favorites, setFavorites] = useState(new Set());
  const [favoritesOnly, setFavoritesOnly] = useState(false);
  // Benchmark filters (minimum scores)
  const [minIntelligenceIndex, setMinIntelligenceIndex] = useState(0);
  const [minCodingIndex, setMinCodingIndex] = useState(0);
  const [minMathIndex, setMinMathIndex] = useState(0);
  const [minAgenticIndex, setMinAgenticIndex] = useState(0);

  const availableAaCols = useMemo(() => {
    if (!aaHeaders || aaHeaders.length === 0) return [];
    const excluded = ['Model', 'Intelligence Index', 'Artificial Analysis Intelligence Index', 'Features: Model', '_normalized_name'];
    return aaHeaders.filter(h => !excluded.includes(h));
  }, [aaHeaders]);
  
  // Group AA columns by category for nicer checkbox layout
  const getAaCategory = (col) => {
    const name = (col || '').toLowerCase();
    if (['intelligence index', 'estimated intelligence index', 'intelligence index per 1m output tokens', 'intelligence index is estimated'].some(k => name === k)) return 'General Intelligence';
    if (['gpqa', 'hle', 'humaneval', 'math 500', 'mmlu pro', 'mmmu pro', 'ifbench', 'scicode', 'livecodebench', 'math index', 'coding index', 'agentic index'].includes(name)) return 'Core Benchmarks';
    if (['aime', 'aime 25', 'lab-claimed aime', 'lab-claimed math 500'].includes(name)) return 'AIME (Math Olympiad)';
    if (['lcr', 'tau-2'].includes(name)) return 'Reasoning / LCR';
    if (['terminalbench hard', 'multilingual aa'].includes(name)) return 'Specialized Leaderboards';
    return 'Other';
  };

  const groupedAaCols = useMemo(() => {
    const groups = {
      'General Intelligence': [],
      'Core Benchmarks': [],
      'AIME (Math Olympiad)': [],
      'Reasoning / LCR': [],
      'Specialized Leaderboards': [],
      'Other': []
    };
    availableAaCols.forEach(col => {
      groups[getAaCategory(col)].push(col);
    });
    return groups;
  }, [availableAaCols]);
  // AA cross-reference mapping view
  const MAPPING_STORAGE_KEY = 'aa_model_mapping_v1';
  const [aaMapping, setAaMapping] = useState([]);

  const STORAGE_KEY = 'openrouter_detailed_stats';
  const STORAGE_TIMESTAMP_KEY = 'openrouter_stats_timestamp';

  // Load cached stats from localStorage on mount
  useEffect(() => {
    const cachedStats = localStorage.getItem(STORAGE_KEY);
    const cachedTimestamp = localStorage.getItem(STORAGE_TIMESTAMP_KEY);
    
    if (cachedStats && cachedTimestamp) {
      try {
        setDetailedStats(JSON.parse(cachedStats));
        setLastUpdated(new Date(cachedTimestamp));
      } catch (err) {
        console.error('Error loading cached stats:', err);
      }
    }
  }, []);

  // Initialize AA mapping from localStorage + seed
  useEffect(() => {
    try {
      const saved = JSON.parse(localStorage.getItem(MAPPING_STORAGE_KEY) || '{}');
      const merged = INITIAL_AA_MAPPING.map(item => ({
        ...item,
        targetId: Object.prototype.hasOwnProperty.call(saved, item.alias) ? saved[item.alias] : item.targetId
      }));
      setAaMapping(merged);
    } catch (e) {
      setAaMapping(INITIAL_AA_MAPPING);
    }
  }, []);

  // Persist AA mapping on change
  useEffect(() => {
    if (!aaMapping || aaMapping.length === 0) return;
    const obj = {};
    aaMapping.forEach(it => { if (it.targetId) obj[it.alias] = it.targetId; });
    try { localStorage.setItem(MAPPING_STORAGE_KEY, JSON.stringify(obj)); } catch (e) {}
  }, [aaMapping]);

  // Load favorites from localStorage on mount
  useEffect(() => {
    try {
      const raw = localStorage.getItem(FAVORITES_STORAGE_KEY);
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) setFavorites(new Set(arr));
      }
    } catch (e) {}
  }, []);
  // Persist favorites on change
  useEffect(() => {
    try { localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(Array.from(favorites))); } catch (e) {}
  }, [favorites]);

  const isFavorite = (id) => favorites.has(id);
  const toggleFavorite = (id, e) => {
    if (e && e.stopPropagation) e.stopPropagation();
    setFavorites(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id); else next.add(id);
      return next;
    });
  };

  const fetchAALeaderboard = () => {
    setAaLoading(true);
    setAaError(null);
    fetch('/api/aa/leaderboard', { cache: 'no-store' })
      .then(r => r.json())
      .then(data => {
        if (data?.aa_index_map) {
          setAaIndexMap(data.aa_index_map);
          setAaHeaders(data.headers || []);
          setAaRows(data.rows || []);
          console.log('AA leaderboard loaded entries:', Object.keys(data.aa_index_map).length);
        } else if (data?.error) {
          setAaError(data.error);
        }
      })
      .catch(err => setAaError(err.message))
      .finally(() => setAaLoading(false));
  };

  // Auto-load AA leaderboard data on page mount if not already loaded
  useEffect(() => {
    if (aaRows.length === 0 && !aaLoading && !aaError) {
      console.log('Auto-loading AA leaderboard data...');
      fetchAALeaderboard();
    }
  }, []); // Run once on mount

  useEffect(() => {
    // Use proxy server if running on localhost, otherwise direct API
    const apiUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? '/api/models'
      : 'https://openrouter.ai/api/v1/models';

    // Always fetch fresh data (no caching)
    fetch(apiUrl, {
      cache: 'no-store',
      headers: {
        'Cache-Control': 'no-cache'
      }
    })
      .then(res => res.json())
      .then(data => {
        setModels(data.data || []);
        setLoading(false);
        console.log(`âœ“ Loaded ${data.data?.length || 0} models from API`);
        // Debug: log first model to see structure
        if (data.data && data.data.length > 0 && !window._modelsLogged) {
          console.log('Sample model data structure:', JSON.stringify(data.data[0], null, 2));
          window._modelsLogged = true;
        }
      })
      .catch(err => {
        console.error('Error fetching models:', err);
        setLoading(false);
      });
  }, []);

  // Auto-load stats if we have models but no cached stats (only once)
  // Only when running via proxy server (localhost)
  useEffect(() => {
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    if (isLocalhost && models.length > 0 && Object.keys(detailedStats).length === 0 && !loadingStats && !hasAttemptedAutoLoad) {
      setHasAttemptedAutoLoad(true);
      const timer = setTimeout(() => {
        loadAllStats();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [models, detailedStats, loadingStats, hasAttemptedAutoLoad]);

  const saveStatsToCache = (stats) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(stats));
      const now = new Date();
      localStorage.setItem(STORAGE_TIMESTAMP_KEY, now.toISOString());
      setLastUpdated(now);
    } catch (err) {
      console.error('Error saving stats to cache:', err);
    }
  };

  // Helper function to calculate average of last N data points from comparison API
  const calculateComparisonAverage = (comparisonData, modelId, numPoints = 3) => {
    if (!comparisonData || !comparisonData.data || comparisonData.data.length === 0) {
      return null;
    }

    // Extract values for this model from all time points
    const values = [];
    for (const dataPoint of comparisonData.data) {
      if (dataPoint.y && dataPoint.y[modelId] !== undefined) {
        values.push(dataPoint.y[modelId]);
      }
    }

    if (values.length === 0) {
      return null;
    }

    // Get last N values
    const lastNValues = values.slice(-numPoints);

    // Calculate average
    const sum = lastNValues.reduce((acc, val) => acc + val, 0);
    return sum / lastNValues.length;
  };

  const fetchDetailedStats = async (model) => {
    try {
      // Use canonical_slug if available, otherwise fall back to id
      const slug = model.canonical_slug || model.id;
      const permaslug = encodeURIComponent(slug);

      // Use proxy server if running on localhost
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

      // URLs for live latency and throughput comparison data
      const latencyUrl = isLocalhost
        ? `/api/stats/latency-e2e-comparison?permaslug=${permaslug}`
        : `https://openrouter.ai/api/frontend/stats/latency-e2e-comparison?permaslug=${permaslug}`;
      const throughputUrl = isLocalhost
        ? `/api/stats/throughput-comparison?permaslug=${permaslug}`
        : `https://openrouter.ai/api/frontend/stats/throughput-comparison?permaslug=${permaslug}`;

      let liveLatency = null;
      let liveThroughput = null;

      // Try multiple variants in order: standard, free, extended
      const variants = ['standard', 'free', 'extended'];

      for (const variant of variants) {
        const url = isLocalhost
          ? `/api/stats?permaslug=${permaslug}&variant=${variant}`
          : `https://openrouter.ai/api/frontend/stats/endpoint?permaslug=${permaslug}&variant=${variant}`;

        const response = await fetch(url);
        const data = await response.json();

        // Fetch comparison data (only on first variant attempt to avoid redundant calls)
        if (variant === 'standard' && liveLatency === null && liveThroughput === null) {
          try {
            const [latencyResponse, throughputResponse] = await Promise.all([
              fetch(latencyUrl),
              fetch(throughputUrl)
            ]);

            const latencyData = await latencyResponse.json();
            const throughputData = await throughputResponse.json();

            // Calculate averages of last 3 data points
            liveLatency = calculateComparisonAverage(latencyData, model.id, 3);
            liveThroughput = calculateComparisonAverage(throughputData, model.id, 3);

            // Debug: log comparison data
            if (!window._comparisonLogged) {
              console.log('Live comparison data:', {
                modelId: model.id,
                liveLatency,
                liveThroughput
              });
              window._comparisonLogged = true;
            }
          } catch (err) {
            console.warn(`Failed to fetch comparison data for ${model.id}:`, err.message);
          }
        }

        // Debug: log first result to see structure
        if (data.data && data.data.length > 0 && !window._statsLogged) {
          console.log('Sample stats data structure:', JSON.stringify(data.data[0], null, 2));
          window._statsLogged = true;
        }

        // If we got valid data, return it with live comparison data
        if (data.data && data.data.length > 0) {
          return {
            modelId: model.id,
            stats: {
              ...data.data[0],
              live_latency: liveLatency,
              live_throughput: liveThroughput
            },
            variant
          };
        }
      }

      // If all variants failed, return null
      return { modelId: model.id, stats: null, error: 'No stats found in any variant' };
    } catch (err) {
      return { modelId: model.id, stats: null, error: err.message };
    }
  };

  const loadAllStats = async () => {
    setLoadingStats(true);
    const total = models.length;
    setStatsProgress({ current: 0, total });

    // Process in batches to avoid overwhelming the API
    const batchSize = 5;
    const batches = [];

    for (let i = 0; i < models.length; i += batchSize) {
      batches.push(models.slice(i, i + batchSize));
    }

    let allStats = { ...detailedStats };
    const modelsWithoutStats = [];

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      const results = await Promise.all(
        batch.map(model => fetchDetailedStats(model))
      );

      // Update accumulated stats
      results.forEach(({ modelId, stats, error }) => {
        if (stats) {
          allStats[modelId] = stats;
        } else {
          // Track models that had no stats
          const model = models.find(m => m.id === modelId);
          if (model) {
            modelsWithoutStats.push({
              id: model.id,
              name: model.name,
              error: error
            });
          }
        }
      });

      // Update state with this batch's results
      setDetailedStats(allStats);

      setStatsProgress({ current: Math.min((i + 1) * batchSize, total), total });

      // Small delay between batches to be nice to the API
      if (i < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }

    // Log models without stats for debugging
    if (modelsWithoutStats.length > 0) {
      console.log(`\nðŸ“Š Models without stats (${modelsWithoutStats.length}):`);
      console.table(modelsWithoutStats);
    }

    // Save to localStorage after all batches complete
    saveStatsToCache(allStats);

    setLoadingStats(false);
    setStatsProgress({ current: total, total });
  };

  const clearCache = () => {
    if (confirm('Are you sure you want to clear all cached data? You will need to reload stats.')) {
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(STORAGE_TIMESTAMP_KEY);
      setDetailedStats({});
      setLastUpdated(null);
    }
  };

  // AA mapping helpers
  const normalizeNameForAA = (str) => {
    if (!str) return '';
    let s = str.replace(/\(.*?\)/g, '');
    s = s.toLowerCase().replace(/\u00a0/g, ' ');
    s = s.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return s;
  };

  const getAaIndexForModel = (model) => {
    if (!aaIndexMap || Object.keys(aaIndexMap).length === 0) return null;
    const nameCand = normalizeNameForAA(model.name);
    const idFull = normalizeNameForAA(model.id);
    const idLast = normalizeNameForAA(model.id.split('/').pop());
    const candidates = [nameCand, idLast, idFull].filter(Boolean);
    for (const c of candidates) {
      if (aaIndexMap[c] !== undefined) return aaIndexMap[c];
    }
    for (const key in aaIndexMap) {
      if (!key) continue;
      if (candidates.some(c => c && (key.includes(c) || c.includes(key)))) {
        return aaIndexMap[key];
      }
    }
    return null;
  };

const modelToAaRowMap = useMemo(() => {
  if (!aaRows || aaRows.length === 0) return new Map();

  const map = new Map();
  const aaRowMap = new Map(aaRows.map(row => [row._normalized_name, row]));

  // First, use manual mappings to associate AA rows with OpenRouter models
  for (const entry of aaMapping) {
    if (entry.targetId) {
      const aliasNorm = normalizeNameForAA(entry.alias);
      if (aaRowMap.has(aliasNorm)) {
        const aaRow = aaRowMap.get(aliasNorm);
        map.set(entry.targetId, aaRow);
      }
    }
  }

  // Fallback: fuzzy matching for unmapped models
  for (const model of models) {
    if (!map.has(model.id)) {
      const nameCand = normalizeNameForAA(model.name);
      const idFull = normalizeNameForAA(model.id);
      const idLast = normalizeNameForAA(model.id.split('/').pop());
      const candidates = [nameCand, idLast, idFull].filter(Boolean);

      let foundRow = null;

      // Exact match
      for (const c of candidates) {
          if (aaRowMap.has(c)) {
              foundRow = aaRowMap.get(c);
              break;
          }
      }

      // Fuzzy match
      if (!foundRow) {
          for (const [normName, row] of aaRowMap.entries()) {
              if (candidates.some(c => c && (normName.includes(c) || c.includes(normName)))) {
                  foundRow = row;
                  break;
              }
          }
      }

      if (foundRow) {
          map.set(model.id, foundRow);
      }
    }
  }
  return map;
}, [models, aaRows, aaMapping]);

  const getAaRowForModel = (model) => {
      return modelToAaRowMap.get(model.id) || null;
  }

  const exportToCSV = () => {
    const headers = [
      'Model Name',
      'Model ID',
      'Context Length',
      'Input Price',
      'Output Price',
      'AA Index',
      'P50 Latency (ms)',
      'P50 Throughput (tok/s)',
      'Max Prompt Tokens',
      'Max Completion Tokens',
      'Supports Reasoning',
      'Supports Tools',
      'Supports JSON',
      'Can Abort',
      'Moderation Required',
      'Is Free',
      'Input Modalities',
      'Provider',
      'Request Count'
    ];
    
    const rows = models.map(model => {
      const stats = detailedStats[model.id];
      const aaIndex = getAaIndexForModel(model);
      return [
        `"${model.name}"`,
        model.id,
        model.context_length || '',
        model.pricing.prompt,
        model.pricing.completion,
        aaIndex ?? '',
        stats?.stats?.p50_latency || stats?.p50_latency || '',
        stats?.stats?.p50_throughput || stats?.p50_throughput || '',
        stats?.max_prompt_tokens || model.top_provider?.context_length || '',
        stats?.max_completion_tokens || model.top_provider?.max_completion_tokens || '',
        hasReasoning(model) ? 'Yes' : 'No',
        model.supported_parameters?.includes('tools') ? 'Yes' : 'No',
        model.supported_parameters?.includes('structured_outputs') ? 'Yes' : 'No',
        stats?.can_abort ? 'Yes' : stats ? 'No' : '',
        stats?.moderation_required ? 'Yes' : stats ? 'No' : '',
        parseFloat(model.pricing.prompt) === 0 ? 'Yes' : 'No',
        `"${model.architecture.input_modalities?.join(', ') || ''}"`,
        stats?.provider_display_name || '',
        stats?.stats?.request_count || ''
      ];
    });
    
    const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `openrouter-models-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const formatPrice = (price) => {
    const num = parseFloat(price);
    if (num === 0) return 'Free';
    if (num < 0.000001) return `$${(num * 1000000).toFixed(4)}/M`;
    if (num < 0.001) return `$${(num * 1000000).toFixed(2)}/M`;
    return `$${num.toFixed(6)}`;
  };

  const formatContext = (ctx) => {
    if (!ctx) return 'N/A';
    if (ctx >= 1000000) return `${(ctx / 1000000).toFixed(1)}M`;
    if (ctx >= 1000) return `${(ctx / 1000).toFixed(0)}K`;
    return ctx.toString();
  };

  const formatLatency = (ms) => {
    if (!ms) return 'N/A';
    if (ms >= 1000) return `${(ms / 1000).toFixed(1)}s`;
    return `${ms.toFixed(0)}ms`;
  };

  const formatTimestamp = (date) => {
    if (!date) return 'Never';
    const now = new Date();
    const diff = now - date;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);
    
    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes} min ago`;
    if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    return `${days} day${days > 1 ? 's' : ''} ago`;
  };

  const hasReasoning = (model) => {
    return model.supported_parameters?.includes('reasoning') ||
           model.supported_parameters?.includes('include_reasoning') ||
           model.description?.toLowerCase().includes('reasoning');
  };

  // Calculate available ranges
  // Context: based on filtered models (excluding context/price to avoid circular dependency)
  // Prices: based on ALL models (so you can always set max to see all price ranges)
  const availableRanges = useMemo(() => {
    if (models.length === 0) {
      return {
        maxContext: 2000000,
        maxPromptPrice: 10000, // per 1M tokens
        maxCompletionPrice: 10000 // per 1M tokens
      };
    }

    // For context, use pre-filtered models (excluding context/price filters)
    const preFiltered = models.filter(m => {
      const matchesSearch = search === '' ||
        m.name.toLowerCase().includes(search.toLowerCase()) ||
        m.id.toLowerCase().includes(search.toLowerCase());

      const matchesModality = filterModality === 'all' ||
        (filterModality === 'text' && m.architecture.modality.includes('text->text')) ||
        (filterModality === 'vision' && m.architecture.modality.includes('image'));

      const matchesReasoning = filterReasoning === 'all' ||
        (filterReasoning === 'yes' && hasReasoning(m)) ||
        (filterReasoning === 'no' && !hasReasoning(m));

      const promptPrice = parseFloat(m.pricing.prompt);
      const completionPrice = parseFloat(m.pricing.completion);
      const isFree = promptPrice === 0 && completionPrice === 0;
      const matchesFree = filterFree === 'all' ||
        (filterFree === 'yes' && isFree) ||
        (filterFree === 'no' && !isFree);

      const hasAnyFeatureFilter = Object.values(filterFeatures).some(v => v);
      const matchesFeatures = !hasAnyFeatureFilter || (
        (!filterFeatures.tools || m.supported_parameters?.includes('tools')) &&
        (!filterFeatures.json || m.supported_parameters?.includes('structured_outputs')) &&
        (!filterFeatures.reasoning || hasReasoning(m))
      );

      return matchesSearch && matchesModality && matchesReasoning && matchesFree && matchesFeatures;
    });

    const contexts = preFiltered.map(m => m.context_length || 0).filter(c => c > 0);

    // For prices, use ALL models to allow full range selection
    // Convert to per 1M tokens (multiply by 1,000,000)
    const allPromptPrices = models.map(m => parseFloat(m.pricing.prompt) * 1000000);
    const allCompletionPrices = models.map(m => parseFloat(m.pricing.completion) * 1000000);

    const fullMaxPromptPrice = Math.max(...allPromptPrices, 0.001);
    const fullMaxCompletionPrice = Math.max(...allCompletionPrices, 0.001);

    // Common range: focus on the majority of models (95th percentile)
    const sortedPrompt = [...allPromptPrices].sort((a, b) => a - b);
    const sortedCompletion = [...allCompletionPrices].sort((a, b) => a - b);
    const p95Index = Math.floor(sortedPrompt.length * 0.95);
    const commonMaxPromptPrice = sortedPrompt[p95Index] || 5;
    const commonMaxCompletionPrice = sortedCompletion[p95Index] || 10;

    return {
      maxContext: contexts.length > 0 ? Math.max(...contexts) : 2000000,
      maxPromptPrice: showFullPriceRange ? fullMaxPromptPrice : commonMaxPromptPrice,
      maxCompletionPrice: showFullPriceRange ? fullMaxCompletionPrice : commonMaxCompletionPrice,
      fullMaxPromptPrice,
      fullMaxCompletionPrice,
      commonMaxPromptPrice,
      commonMaxCompletionPrice
    };
  }, [models, search, filterModality, filterReasoning, filterFree, filterFeatures, showFullPriceRange]);

  const filteredAndSorted = useMemo(() => {
    let filtered = models.filter(m => {
      const matchesSearch = search === '' ||
        m.name.toLowerCase().includes(search.toLowerCase()) ||
        m.id.toLowerCase().includes(search.toLowerCase());

      const matchesModality = filterModality === 'all' ||
        (filterModality === 'text' && m.architecture.modality.includes('text->text')) ||
        (filterModality === 'vision' && m.architecture.modality.includes('image'));

      const matchesReasoning = filterReasoning === 'all' ||
        (filterReasoning === 'yes' && hasReasoning(m)) ||
        (filterReasoning === 'no' && !hasReasoning(m));

      // Free/Paid filter
      const promptPrice = parseFloat(m.pricing.prompt);
      const completionPrice = parseFloat(m.pricing.completion);
      const isFree = promptPrice === 0 && completionPrice === 0;
      const matchesFree = filterFree === 'all' ||
        (filterFree === 'yes' && isFree) ||
        (filterFree === 'no' && !isFree);

      // Feature filters: ALL checked features must be present (AND logic)
      const hasAnyFeatureFilter = Object.values(filterFeatures).some(v => v);
      const matchesFeatures = !hasAnyFeatureFilter || (
        (!filterFeatures.tools || m.supported_parameters?.includes('tools')) &&
        (!filterFeatures.json || m.supported_parameters?.includes('structured_outputs')) &&
        (!filterFeatures.reasoning || hasReasoning(m))
      );

      // Context length filter: must be >= minimum
      const contextLength = m.context_length || 0;
      const matchesContext = contextLength >= minContext;

      // Price filters: BOTH prices must be within limits (unless it's free and free filter is active)
      // Convert to per 1M tokens for comparison
      const promptPricePer1M = promptPrice * 1000000;
      const completionPricePer1M = completionPrice * 1000000;
      const matchesPrice = (filterFree === 'yes' && isFree) ||
        (promptPricePer1M <= maxPromptPrice && completionPricePer1M <= maxCompletionPrice);

      // Benchmark filters: check minimum scores
      const aaRow = modelToAaRowMap.get(m.id);
      const intelligenceIndex = aaRow?.['Intelligence Index'] || 0;
      const codingIndex = aaRow?.['Coding Index'] || 0;
      const mathIndex = aaRow?.['Math Index'] || 0;
      const agenticIndex = aaRow?.['Agentic Index'] || 0;

      const matchesBenchmarks = (minIntelligenceIndex === 0 || intelligenceIndex >= minIntelligenceIndex) &&
                                (minCodingIndex === 0 || codingIndex >= minCodingIndex) &&
                                (minMathIndex === 0 || mathIndex >= minMathIndex) &&
                                (minAgenticIndex === 0 || agenticIndex >= minAgenticIndex);

      const matchesFavorites = !favoritesOnly || favorites.has(m.id);
      return matchesSearch && matchesModality && matchesReasoning && matchesFree && matchesFeatures && matchesContext && matchesPrice && matchesBenchmarks && matchesFavorites;
    });

    filtered.sort((a, b) => {
      let aVal, bVal;
      
      switch(sortBy) {
        case 'name':
          aVal = a.name.toLowerCase();
          bVal = b.name.toLowerCase();
          break;
        case 'context':
          aVal = a.context_length || 0;
          bVal = b.context_length || 0;
          break;
        case 'prompt':
          aVal = parseFloat(a.pricing.prompt);
          bVal = parseFloat(b.pricing.prompt);
          break;
        case 'completion':
          aVal = parseFloat(a.pricing.completion);
          bVal = parseFloat(b.pricing.completion);
          break;
        case 'aa_index':
          aVal = getAaIndexForModel(a) ?? -1;
          bVal = getAaIndexForModel(b) ?? -1;
          break;
        case 'latency':
          aVal = detailedStats[a.id]?.stats?.live_latency || detailedStats[a.id]?.live_latency ||
                 detailedStats[a.id]?.stats?.p50_latency || detailedStats[a.id]?.p50_latency || 999999;
          bVal = detailedStats[b.id]?.stats?.live_latency || detailedStats[b.id]?.live_latency ||
                 detailedStats[b.id]?.stats?.p50_latency || detailedStats[b.id]?.p50_latency || 999999;
          break;
        case 'throughput':
          aVal = detailedStats[a.id]?.stats?.live_throughput || detailedStats[a.id]?.live_throughput ||
                 detailedStats[a.id]?.stats?.p50_throughput || detailedStats[a.id]?.p50_throughput || 0;
          bVal = detailedStats[b.id]?.stats?.live_throughput || detailedStats[b.id]?.live_throughput ||
                 detailedStats[b.id]?.stats?.p50_throughput || detailedStats[b.id]?.p50_throughput || 0;
          break;
        case 'created':
          aVal = a.created || 0;
          bVal = b.created || 0;
          break;
        default:
          // Support sorting by dynamic AA benchmark columns
          if (sortBy && sortBy.startsWith('aa:')) {
            const col = sortBy.slice(3);
            const aRow = modelToAaRowMap.get(a.id);
            const bRow = modelToAaRowMap.get(b.id);
            const parseNum = (v) => {
              if (v === null || v === undefined) return -1;
              if (typeof v === 'number') return v;
              if (typeof v === 'string') {
                const s = v.replace(/%/g, '').replace(/,/g, '').trim();
                const f = parseFloat(s);
                return isNaN(f) ? -1 : f;
              }
              return -1;
            };
            aVal = parseNum(aRow ? aRow[col] : undefined);
            bVal = parseNum(bRow ? bRow[col] : undefined);
          } else {
            return 0;
          }
      }
      
      if (aVal < bVal) return sortDir === 'asc' ? -1 : 1;
      if (aVal > bVal) return sortDir === 'asc' ? 1 : -1;
      return 0;
    });

    return filtered;
  }, [models, search, sortBy, sortDir, filterModality, filterReasoning, filterFree, filterFeatures, minContext, maxPromptPrice, maxCompletionPrice, detailedStats, modelToAaRowMap, minIntelligenceIndex, minCodingIndex, minMathIndex, minAgenticIndex, favoritesOnly, favorites]);

  const handleSort = (field) => {
    if (sortBy === field) {
      setSortDir(sortDir === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(field);
      setSortDir('asc');
    }
  };

  const SortIcon = ({ field }) => {
    if (sortBy !== field) return null;
    return sortDir === 'asc' ? <ChevronUp className="w-4 h-4 inline ml-1" /> : <ChevronDown className="w-4 h-4 inline ml-1" />;
  };

  const toggleExpand = async (modelId) => {
    setExpandedRow(expandedRow === modelId ? null : modelId);
  };

  const copyModelId = (modelId, event) => {
    event.stopPropagation(); // Prevent row expansion when clicking copy
    navigator.clipboard.writeText(modelId).then(() => {
      // Could add a toast notification here
      console.log('Copied to clipboard:', modelId);
    }).catch(err => {
      console.error('Failed to copy:', err);
    });
  };

  const statsLoadedCount = Object.keys(detailedStats).length;
  const statsLoadedPercent = models.length > 0 ? Math.round((statsLoadedCount / models.length) * 100) : 0;

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading models...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 p-4 md:p-8">
      <div className="max-w-7xl mx-auto">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">OpenRouter Models Dashboard</h1>
          <p className="text-gray-600">{filteredAndSorted.length} of {models.length} models</p>

          {/* Tabs */}
          <div className="flex gap-2 mt-4 border-b border-gray-200">
            <button
              onClick={() => setActiveTab('table')}
              className={`px-4 py-2 font-medium border-b-2 transition-colors ${
                activeTab === 'table'
                  ? 'border-blue-600 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              Table View
            </button>
            <button
              onClick={() => setActiveTab('chart')}
              className={`px-4 py-2 font-medium border-b-2 transition-colors ${
                activeTab === 'chart'
                  ? 'border-blue-600 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              Chart View
            </button>
            <button
              onClick={() => setActiveTab('heatmap')}
              className={`px-4 py-2 font-medium border-b-2 transition-colors ${
                activeTab === 'heatmap'
                  ? 'border-blue-600 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              Heatmap View
            </button>
            <button
              onClick={() => setActiveTab('mapping')}
              className={`px-4 py-2 font-medium border-b-2 transition-colors ${
                activeTab === 'mapping'
                  ? 'border-blue-600 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              AA Mapping
            </button>
          </div>

          <div className="flex items-center gap-4 mt-2">
            {statsLoadedCount > 0 && (
              <p className="text-sm text-gray-500">
                Performance stats loaded: {statsLoadedCount}/{models.length} ({statsLoadedPercent}%)
              </p>
            )}
            {lastUpdated && (
              <p className="text-sm text-gray-500 flex items-center gap-1">
                <Save className="w-3 h-3" />
                Last updated: {formatTimestamp(lastUpdated)}
              </p>
            )}
          </div>
        </div>

        {window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1' && (
          <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
            <div className="flex">
              <AlertCircle className="w-5 h-5 text-yellow-400 mr-3 flex-shrink-0" />
              <div className="text-sm text-yellow-700">
                <strong>Note:</strong> Performance stats (latency/throughput) require running the Python proxy server.
                See README for instructions: <code className="bg-yellow-100 px-1 rounded">python3 server.py</code>
              </div>
            </div>
          </div>
        )}

        <div className="bg-white rounded-lg shadow-sm p-4 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
            <div className="lg:col-span-2">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
                <input
                  type="text"
                  placeholder="Search models..."
                  value={search}
                  onChange={(e) => setSearch(e.target.value)}
                  className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
            </div>

            <div>
              <select
                value={filterModality}
                onChange={(e) => setFilterModality(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">All Modalities</option>
                <option value="text">Text Only</option>
                <option value="vision">Vision</option>
              </select>
            </div>

            <div>
              <select
                value={filterReasoning}
                onChange={(e) => setFilterReasoning(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">All Models</option>
                <option value="yes">With Reasoning</option>
                <option value="no">Without Reasoning</option>
              </select>
            </div>

            <div>
              <select
                value={filterFree}
                onChange={(e) => setFilterFree(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">All Pricing</option>
                <option value="yes">Free Only</option>
                <option value="no">Paid Only</option>
              </select>
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
            {/* Feature checkboxes */}
            <div className="lg:col-span-2">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Required Features
              </label>
              <p className="text-xs text-gray-500 mb-2">Models must have ALL checked features (AND logic)</p>
              <div className="flex flex-wrap gap-4">
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={filterFeatures.tools}
                    onChange={(e) => setFilterFeatures({...filterFeatures, tools: e.target.checked})}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                  />
                  <span className="text-sm text-gray-700">Tools</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={filterFeatures.json}
                    onChange={(e) => setFilterFeatures({...filterFeatures, json: e.target.checked})}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                  />
                  <span className="text-sm text-gray-700">JSON/Structured</span>
                </label>
                <label className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    checked={filterFeatures.reasoning}
                    onChange={(e) => setFilterFeatures({...filterFeatures, reasoning: e.target.checked})}
                    className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                  />
                  <span className="text-sm text-gray-700 flex items-center gap-1">
                    <Brain className="w-3 h-3" />
                    Reasoning/Thinking
                  </span>
                </label>
              </div>
            </div>

            {/* Min Context Slider */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Min Context: {minContext >= 1000000 ? `${(minContext/1000000).toFixed(1)}M` : minContext >= 1000 ? `${(minContext/1000).toFixed(0)}K` : minContext}
              </label>
              <input
                type="range"
                min="0"
                max={availableRanges.maxContext}
                step="10000"
                value={Math.min(minContext, availableRanges.maxContext)}
                onChange={(e) => setMinContext(parseInt(e.target.value))}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>0</span>
                <span>{availableRanges.maxContext >= 1000000 ? `${(availableRanges.maxContext/1000000).toFixed(1)}M` : `${(availableRanges.maxContext/1000).toFixed(0)}K`}</span>
              </div>
            </div>

            {/* Max Input Price Slider */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Max Input Price: ${maxPromptPrice.toFixed(2)}/1M tokens
              </label>
              <div className="flex items-center gap-2 mb-2">
                <label className="flex items-center text-xs text-gray-600 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={showFullPriceRange}
                    onChange={(e) => setShowFullPriceRange(e.target.checked)}
                    className="w-3 h-3 text-blue-600 rounded mr-1"
                  />
                  Show full range (${availableRanges.fullMaxPromptPrice?.toFixed(0)})
                </label>
              </div>
              <input
                type="range"
                min="0"
                max={availableRanges.maxPromptPrice}
                step={Math.max(0.01, availableRanges.maxPromptPrice / 1000)}
                value={Math.min(maxPromptPrice, availableRanges.maxPromptPrice)}
                onChange={(e) => setMaxPromptPrice(parseFloat(e.target.value))}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>$0</span>
                <span>${availableRanges.maxPromptPrice.toFixed(2)}</span>
              </div>
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
            <div className="lg:col-span-2"></div>
            <div></div>
            {/* Max Output Price Slider */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Favorites
              </label>
              <label className="flex items-center gap-2 text-sm text-gray-700 mb-2">
                <input
                  type="checkbox"
                  checked={favoritesOnly}
                  onChange={(e) => setFavoritesOnly(e.target.checked)}
                  className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                />
                <span className="flex items-center gap-1">
                  <StarFilled className={`w-4 h-4 ${favoritesOnly ? 'text-yellow-500' : 'text-gray-400'}`} />
                  Show favorites only
                </span>
              </label>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Max Output Price: ${maxCompletionPrice.toFixed(2)}/1M tokens
              </label>
              <div className="flex items-center gap-2 mb-2">
                <label className="flex items-center text-xs text-gray-600 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={showFullPriceRange}
                    onChange={(e) => setShowFullPriceRange(e.target.checked)}
                    className="w-3 h-3 text-blue-600 rounded mr-1"
                  />
                  Show full range (${availableRanges.fullMaxCompletionPrice?.toFixed(0)})
                </label>
              </div>
              <input
                type="range"
                min="0"
                max={availableRanges.maxCompletionPrice}
                step={Math.max(0.01, availableRanges.maxCompletionPrice / 1000)}
                value={Math.min(maxCompletionPrice, availableRanges.maxCompletionPrice)}
                onChange={(e) => setMaxCompletionPrice(parseFloat(e.target.value))}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>$0</span>
                <span>${availableRanges.maxCompletionPrice.toFixed(2)}</span>
              </div>
            </div>
          </div>

          {availableAaCols.length > 0 && (
            <div className="lg:col-span-4 mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                AA Leaderboard Columns
              </label>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {Object.entries(groupedAaCols).map(([groupName, cols]) => (
                  cols.length > 0 && (
                    <div key={groupName} className="border rounded-lg p-3">
                      <div className="text-xs font-semibold text-gray-600 mb-2">{groupName}</div>
                      <div className="flex flex-col gap-2">
                        {cols.map(col => (
                          <label key={col} className="flex items-center gap-2 relative group">
                            <input
                              type="checkbox"
                              checked={visibleAaCols.includes(col)}
                              onChange={(e) => {
                                if (e.target.checked) {
                                  setVisibleAaCols([...visibleAaCols, col]);
                                } else {
                                  setVisibleAaCols(visibleAaCols.filter(c => c !== col));
                                }
                              }}
                              className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                            />
                            <span className="text-sm text-gray-700 flex items-center gap-1">
                              {col}
                              {BENCHMARK_DESCRIPTIONS[col] && (
                                <>
                                  <Info className="w-3.5 h-3.5 text-gray-400 cursor-help" />
                                  <span className="invisible group-hover:visible absolute left-0 top-full mt-1 w-72 bg-gray-900 text-white text-xs rounded-lg p-2 z-50 shadow-xl">
                                    {BENCHMARK_DESCRIPTIONS[col]}
                                  </span>
                                </>
                              )}
                            </span>
                          </label>
                        ))}
                      </div>
                    </div>
                  )
                ))}
              </div>
            </div>
          )}

          {/* Benchmark Filters */}
          {aaRows.length > 0 && (
            <div className="lg:col-span-4 mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Benchmark Filters (Minimum Scores)
              </label>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-xs text-gray-600 mb-1">
                    Min Intelligence Index: {minIntelligenceIndex}
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={minIntelligenceIndex}
                    onChange={(e) => setMinIntelligenceIndex(parseInt(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  />
                </div>
                <div>
                  <label className="block text-xs text-gray-600 mb-1">
                    Min Coding Index: {minCodingIndex}
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={minCodingIndex}
                    onChange={(e) => setMinCodingIndex(parseInt(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  />
                </div>
                <div>
                  <label className="block text-xs text-gray-600 mb-1">
                    Min Math Index: {minMathIndex}
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={minMathIndex}
                    onChange={(e) => setMinMathIndex(parseInt(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  />
                </div>
                <div>
                  <label className="block text-xs text-gray-600 mb-1">
                    Min Agentic Index: {minAgenticIndex}
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value={minAgenticIndex}
                    onChange={(e) => setMinAgenticIndex(parseInt(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  />
                </div>
              </div>
            </div>
          )}
          
          <div className="flex justify-between items-center">
            <div>
              {loadingStats && (
                <div className="text-sm text-gray-600">
                  Loading stats: {statsProgress.current} / {statsProgress.total}
                  <div className="w-48 bg-gray-200 rounded-full h-2 mt-1">
                    <div
                      className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${(statsProgress.current / statsProgress.total) * 100}%` }}
                    ></div>
                  </div>
                </div>
              )}
            </div>
            <div className="flex gap-2">
              {statsLoadedCount > 0 && (
                <button
                  onClick={clearCache}
                  className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 flex items-center gap-2"
                >
                  <XCircle className="w-4 h-4" />
                  Clear Cache
                </button>
              )}
              <button
                onClick={exportToCSV}
                className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center gap-2"
              >
                <Download className="w-4 h-4" />
                Export CSV
              </button>
              <button
                onClick={loadAllStats}
                disabled={loadingStats}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center gap-2"
              >
                {loadingStats ? (
                  <>
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                    Loading...
                  </>
                ) : (
                  <>
                    <RefreshCw className="w-4 h-4" />
                    {statsLoadedCount > 0 ? 'Refresh' : 'Load'} All Stats
                  </>
                )}
              </button>
            </div>
          </div>
        </div>

        {activeTab === 'table' && (
        <div className="bg-white rounded-lg shadow-sm overflow-hidden">
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 border-b border-gray-200">
                <tr>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                  <th 
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('name')}
                  >
                    Model <SortIcon field="name" />
                  </th>
                  <th 
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('context')}
                  >
                    Context <SortIcon field="context" />
                  </th>
                  <th 
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('prompt')}
                  >
                    Input <SortIcon field="prompt" />
                  </th>
                  <th
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('completion')}
                  >
                    Output <SortIcon field="completion" />
                  </th>
                  <th
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('aa_index')}
                  >
                    AA Index <SortIcon field="aa_index" />
                  </th>
                  <th
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('latency')}
                  >
                    <Clock className="w-4 h-4 inline mr-1" />
                    Latency <SortIcon field="latency" />
                  </th>
                  <th
                    className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                    onClick={() => handleSort('throughput')}
                  >
                    <Zap className="w-4 h-4 inline mr-1" />
                    Speed <SortIcon field="throughput" />
                  </th>
                  {visibleAaCols.map(col => (
                    <th
                      key={col}
                      className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider group relative cursor-pointer hover:bg-gray-100"
                      title={BENCHMARK_DESCRIPTIONS[col] || ''}
                      onClick={() => handleSort(`aa:${col}`)}
                    >
                      <span className="flex items-center gap-1">
                        {col} <SortIcon field={`aa:${col}`} />
                        {BENCHMARK_DESCRIPTIONS[col] && (
                          <Info className="w-3 h-3 text-gray-400" />
                        )}
                      </span>
                    </th>
                  ))}
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Features
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {filteredAndSorted.map((model) => {
                  const stats = detailedStats[model.id];
                  const aaIndex = getAaIndexForModel(model);
                  const aaRow = getAaRowForModel(model);
                  return (
                    <React.Fragment key={model.id}>
                      <tr className="hover:bg-gray-50 transition-colors cursor-pointer" onClick={() => toggleExpand(model.id)}>
                        <td className="px-4 py-3 text-center">
                          {expandedRow === model.id ? (
                            <ChevronUp className="w-4 h-4 text-gray-400" />
                          ) : (
                            <ChevronDown className="w-4 h-4 text-gray-400" />
                          )}
                        </td>
                        <td className="px-4 py-3">
                          <div className="flex items-center gap-2">
                            <div className="flex flex-col flex-1">
                              <span className="text-sm font-medium text-gray-900">{model.name}</span>
                              <span className="text-xs text-gray-500">{model.id}</span>
                            </div>
                            <button
                              onClick={(e) => toggleFavorite(model.id, e)}
                              className="p-1.5 hover:bg-gray-200 rounded transition-colors"
                              title={isFavorite(model.id) ? 'Remove from favorites' : 'Add to favorites'}
                            >
                              {isFavorite(model.id) ? (
                                <StarFilled className="w-4 h-4 text-yellow-500" />
                              ) : (
                                <Star className="w-4 h-4 text-gray-400" />
                              )}
                            </button>
                            <button
                              onClick={(e) => copyModelId(model.id, e)}
                              className="p-1.5 hover:bg-gray-200 rounded transition-colors"
                              title="Copy model ID"
                            >
                              <Copy className="w-4 h-4 text-gray-500 hover:text-gray-700" />
                            </button>
                          </div>
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-sm text-gray-900">{formatContext(model.context_length)}</span>
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-sm text-gray-900">{formatPrice(model.pricing.prompt)}</span>
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-sm text-gray-900">{formatPrice(model.pricing.completion)}</span>
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-sm text-gray-900">{aaIndex !== null && aaIndex !== undefined ? `${aaIndex}` : '-'}</span>
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-sm text-gray-900">
                            {stats?.stats?.live_latency ? formatLatency(stats.stats.live_latency) :
                             stats?.live_latency ? formatLatency(stats.live_latency) :
                             stats?.stats?.p50_latency ? formatLatency(stats.stats.p50_latency) :
                             stats?.p50_latency ? formatLatency(stats.p50_latency) : '-'}
                          </span>
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-sm text-gray-900">
                            {stats?.stats?.live_throughput ? `${stats.stats.live_throughput.toFixed(1)} tok/s` :
                             stats?.live_throughput ? `${stats.live_throughput.toFixed(1)} tok/s` :
                             stats?.stats?.p50_throughput ? `${stats.stats.p50_throughput.toFixed(1)} tok/s` :
                             stats?.p50_throughput ? `${stats.p50_throughput.toFixed(1)} tok/s` : '-'}
                          </span>
                        </td>
                        {visibleAaCols.map(col => (
                            <td key={col} className="px-4 py-3">
                                <span className="text-sm text-gray-900">{aaRow ? aaRow[col] : '-'}</span>
                            </td>
                        ))}
                        <td className="px-4 py-3">
                          <div className="flex flex-wrap gap-1">
                            {hasReasoning(model) && (
                              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800">
                                <Brain className="w-3 h-3 mr-1" />
                                Reasoning
                              </span>
                            )}
                            {model.supported_parameters?.includes('tools') && (
                              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                                Tools
                              </span>
                            )}
                            {model.supported_parameters?.includes('structured_outputs') && (
                              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
                                JSON
                              </span>
                            )}
                            {parseFloat(model.pricing.prompt) === 0 && (
                              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-emerald-100 text-emerald-800">
                                Free
                              </span>
                            )}
                          </div>
                        </td>
                      </tr>
                      {expandedRow === model.id && (
                        <tr className="bg-gray-50">
                          <td colSpan="9" className="px-4 py-4">
                            <div className="space-y-4">
                              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                                <div className="space-y-2">
                                  <h4 className="font-semibold text-gray-900 mb-2">Model Details</h4>
                                  <div className="flex justify-between">
                                    <span className="text-gray-600">Max Prompt:</span>
                                    <span className="font-medium">{formatContext(stats?.max_prompt_tokens || model.top_provider?.context_length)}</span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span className="text-gray-600">Max Completion:</span>
                                    <span className="font-medium">{formatContext(stats?.max_completion_tokens || model.top_provider?.max_completion_tokens)}</span>
                                  </div>
                                  <div className="flex justify-between">
                                    <span className="text-gray-600">Can Abort:</span>
                                    <span className="font-medium">{stats?.can_abort ? 'âœ“' : stats ? 'âœ—' : 'N/A'}</span>
                                  </div>
                                  {stats?.stats && (
                                    <div className="flex justify-between">
                                      <span className="text-gray-600">Requests:</span>
                                      <span className="font-medium">{stats.stats.request_count?.toLocaleString()}</span>
                                    </div>
                                  )}
                                </div>

                                <div className="space-y-2">
                                  <h4 className="font-semibold text-gray-900 mb-2">Capabilities</h4>
                                  <div className="space-y-1">
                                    <div className="flex items-center gap-2">
                                      {hasReasoning(model) ? (
                                        <CheckCircle className="w-4 h-4 text-green-600" />
                                      ) : (
                                        <XCircle className="w-4 h-4 text-gray-300" />
                                      )}
                                      <span className="text-gray-700 flex items-center gap-1">
                                        <Brain className="w-3 h-3" />
                                        Reasoning/Thinking
                                      </span>
                                    </div>
                                    <div className="flex items-center gap-2">
                                      {stats?.supports_multipart ? (
                                        <CheckCircle className="w-4 h-4 text-green-600" />
                                      ) : (
                                        <XCircle className="w-4 h-4 text-gray-300" />
                                      )}
                                      <span className="text-gray-700">Multipart</span>
                                    </div>
                                    <div className="flex items-center gap-2">
                                      {stats?.moderation_required ? (
                                        <AlertCircle className="w-4 h-4 text-yellow-600" />
                                      ) : (
                                        <CheckCircle className="w-4 h-4 text-green-600" />
                                      )}
                                      <span className="text-gray-700">Moderation {stats?.moderation_required ? 'Required' : 'Optional'}</span>
                                    </div>
                                  </div>
                                </div>

                                <div className="space-y-2">
                                  <h4 className="font-semibold text-gray-900 mb-2">Modalities</h4>
                                  <div className="flex flex-wrap gap-1">
                                    {model.architecture.input_modalities?.map((mod) => (
                                      <span key={mod} className="inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-blue-50 text-blue-700 border border-blue-200">
                                        {mod}
                                      </span>
                                    ))}
                                  </div>
                                </div>
                              </div>

                              {model.description && (
                                <div className="pt-3 border-t border-gray-200">
                                  <h4 className="font-semibold text-gray-900 mb-2 text-sm">Description</h4>
                                  <p className="text-sm text-gray-700 leading-relaxed whitespace-pre-wrap">{renderMarkdownLinks(model.description)}</p>
                                </div>
                              )}
                            </div>
                          </td>
                        </tr>
                      )}
                    </React.Fragment>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
        )}

        {activeTab === 'chart' && (
          <ScatterPlot
            models={filteredAndSorted}
            detailedStats={detailedStats}
            xAxis={plotXAxis}
            yAxis={plotYAxis}
            onXAxisChange={setPlotXAxis}
            onYAxisChange={setPlotYAxis}
            formatPrice={formatPrice}
            modelToAaRowMap={modelToAaRowMap}
          />
        )}

        {activeTab === 'heatmap' && (
          <HeatmapView
            models={filteredAndSorted}
            detailedStats={detailedStats}
            xAxis={heatmapXAxis}
            yAxis={heatmapYAxis}
            colorAxis={heatmapColorAxis}
            onXAxisChange={setHeatmapXAxis}
            onYAxisChange={setHeatmapYAxis}
            onColorAxisChange={setHeatmapColorAxis}
            formatPrice={formatPrice}
            modelToAaRowMap={modelToAaRowMap}
          />
        )}

        {activeTab === 'mapping' && (
          <MappingView
            models={models}
            mapping={aaMapping}
            setMapping={setAaMapping}
            fetchAALeaderboard={fetchAALeaderboard}
            aaLoading={aaLoading}
            aaError={aaError}
          />
        )}

        <div className="mt-6 text-center text-sm text-gray-500">
          <p>ðŸ’¾ Data automatically saved to browser cache â€¢ Click "Refresh All Stats" to update â€¢ Export to CSV anytime</p>
        </div>
      </div>
    </div>
  );
};

const ScatterPlot = ({ models, detailedStats, xAxis, yAxis, onXAxisChange, onYAxisChange, formatPrice, modelToAaRowMap }) => {
  const [hoveredModel, setHoveredModel] = useState(null);
  const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
  const [showLabels, setShowLabels] = useState(true);
  const [zoomLevel, setZoomLevel] = useState(1);

  const getAxisValue = (model, axis) => {
    const stats = detailedStats[model.id];
    const aaRow = modelToAaRowMap?.get(model.id);

    switch(axis) {
      case 'latency':
        return stats?.stats?.live_latency || stats?.live_latency ||
               stats?.stats?.p50_latency || stats?.p50_latency || null;
      case 'throughput':
        return stats?.stats?.live_throughput || stats?.live_throughput ||
               stats?.stats?.p50_throughput || stats?.p50_throughput || null;
      case 'prompt_price':
        return parseFloat(model.pricing.prompt);
      case 'completion_price':
        return parseFloat(model.pricing.completion);
      case 'context_length':
        return model.context_length || null;
      case 'request_count':
        return stats?.stats?.request_count || null;
      // AA Benchmark metrics
      case 'intelligence_index':
        return aaRow?.['Intelligence Index'] || null;
      case 'estimated_intelligence_index':
        return aaRow?.['Estimated Intelligence Index'] || null;
      case 'intelligence_index_per_m_output_tokens':
        return aaRow?.['Intelligence Index per 1M Output Tokens'] || null;
      case 'gpqa':
        return aaRow?.['GPQA'] || null;
      case 'hle':
        return aaRow?.['HLE'] || null;
      case 'humaneval':
        return aaRow?.['HumanEval'] || null;
      case 'math_500':
        return aaRow?.['Math 500'] || null;
      case 'mmlu_pro':
        return aaRow?.['MMLU Pro'] || null;
      case 'mmmu_pro':
        return aaRow?.['MMMU Pro'] || null;
      case 'ifbench':
        return aaRow?.['IFBench'] || null;
      case 'math_index':
        return aaRow?.['Math Index'] || null;
      case 'coding_index':
        return aaRow?.['Coding Index'] || null;
      case 'agentic_index':
        return aaRow?.['Agentic Index'] || null;
      case 'livecodebench':
        return aaRow?.['LiveCodeBench'] || null;
      case 'scicode':
        return aaRow?.['SciCode'] || null;
      case 'aime':
        return aaRow?.['AIME'] || null;
      case 'aime25':
        return aaRow?.['AIME 25'] || null;
      case 'lab_claimed_aime':
        return aaRow?.['Lab-Claimed AIME'] || null;
      case 'lab_claimed_math_500':
        return aaRow?.['Lab-Claimed Math 500'] || null;
      case 'lcr':
        return aaRow?.['LCR'] || null;
      case 'tau2':
        return aaRow?.['TAU-2'] || null;
      case 'terminalbench_hard':
        return aaRow?.['TerminalBench Hard'] || null;
      case 'multilingual_aa':
        return aaRow?.['Multilingual AA'] || null;
      default:
        return null;
    }
  };

  const getAxisLabel = (axis) => {
    switch(axis) {
      case 'latency': return 'Latency (ms)';
      case 'throughput': return 'Throughput (tok/s)';
      case 'prompt_price': return 'Input Price ($)';
      case 'completion_price': return 'Output Price ($)';
      case 'context_length': return 'Context Length';
      case 'request_count': return 'Request Count';
      // AA Benchmark metrics
      case 'intelligence_index': return 'Intelligence Index';
      case 'estimated_intelligence_index': return 'Estimated Intelligence Index';
      case 'intelligence_index_per_m_output_tokens': return 'Intelligence Index per 1M Output Tokens';
      case 'gpqa': return 'GPQA Score';
      case 'hle': return 'HLE Score';
      case 'humaneval': return 'HumanEval Score';
      case 'math_500': return 'Math 500 Score';
      case 'mmlu_pro': return 'MMLU Pro Score';
      case 'mmmu_pro': return 'MMMU Pro Score';
      case 'ifbench': return 'IFBench Score';
      case 'math_index': return 'Math Index';
      case 'coding_index': return 'Coding Index';
      case 'agentic_index': return 'Agentic Index';
      case 'livecodebench': return 'LiveCodeBench Score';
      case 'scicode': return 'SciCode Score';
      case 'aime': return 'AIME Score';
      case 'aime25': return 'AIME 25 Score';
      case 'lab_claimed_aime': return 'Lab-Claimed AIME';
      case 'lab_claimed_math_500': return 'Lab-Claimed Math 500';
      case 'lcr': return 'LCR';
      case 'tau2': return 'TAU-2';
      case 'terminalbench_hard': return 'TerminalBench Hard';
      case 'multilingual_aa': return 'Multilingual AA';
      default: return axis;
    }
  };

  // Filter models that have both x and y values
  const plotData = models
    .map(model => ({
      model,
      x: getAxisValue(model, xAxis),
      y: getAxisValue(model, yAxis)
    }))
    .filter(d => d.x !== null && d.y !== null && !isNaN(d.x) && !isNaN(d.y));

  if (plotData.length === 0) {
    return (
      <div className="bg-white rounded-lg shadow-sm p-8 text-center">
        <p className="text-gray-500">No data available for the selected axes. Try loading stats first or selecting different metrics.</p>
      </div>
    );
  }

  const xValues = plotData.map(d => d.x);
  const yValues = plotData.map(d => d.y);
  const xMin = Math.min(...xValues);
  const xMax = Math.max(...xValues);
  const yMin = Math.min(...yValues);
  const yMax = Math.max(...yValues);

  const padding = 80;
  const baseWidth = 1400;
  const baseHeight = 900;
  const width = baseWidth * zoomLevel;
  const height = baseHeight * zoomLevel;
  const plotWidth = width - 2 * padding;
  const plotHeight = height - 2 * padding;

  const scaleX = (val) => padding + ((val - xMin) / (xMax - xMin)) * plotWidth;
  const scaleY = (val) => height - padding - ((val - yMin) / (yMax - yMin)) * plotHeight;

  const formatValue = (val, axis) => {
    if (axis.includes('price')) return `$${val.toFixed(6)}`;
    if (axis === 'latency') return `${val.toFixed(0)}ms`;
    if (axis === 'throughput') return `${val.toFixed(1)} tok/s`;
    if (axis === 'context_length') return val >= 1000000 ? `${(val/1000000).toFixed(1)}M` : `${(val/1000).toFixed(0)}K`;
    if (axis === 'request_count') return val.toLocaleString();
  // AA Benchmark metrics - typically range from 0-100 or 0-1
  if (axis === 'intelligence_index' || axis === 'estimated_intelligence_index' || axis === 'math_index' || axis === 'coding_index' || axis === 'agentic_index') {
    return val.toFixed(1);
  }
  if (['gpqa','hle','humaneval','math_500','mmlu_pro','mmmu_pro','ifbench','livecodebench','scicode','aime','aime25','lcr','tau2','terminalbench_hard','multilingual_aa'].includes(axis)) {
    // These are typically percentages (0-1 range)
    return val < 2 ? `${(val * 100).toFixed(1)}%` : val.toFixed(1);
  }
    return val.toFixed(2);
  };

  const axisOptions = [
    { value: 'latency', label: 'Latency' },
    { value: 'throughput', label: 'Throughput' },
    { value: 'prompt_price', label: 'Input Price' },
    { value: 'completion_price', label: 'Output Price' },
    { value: 'context_length', label: 'Context Length' },
    { value: 'request_count', label: 'Request Count' },
    { value: '---', label: '--- AA Benchmarks ---', disabled: true },
    { value: 'intelligence_index', label: 'Intelligence Index' },
    { value: 'estimated_intelligence_index', label: 'Estimated Intelligence Index' },
    { value: 'intelligence_index_per_m_output_tokens', label: 'Intelligence per $ (1M out)' },
    { value: 'gpqa', label: 'GPQA' },
    { value: 'hle', label: 'HLE' },
    { value: 'humaneval', label: 'HumanEval' },
    { value: 'math_500', label: 'Math 500' },
    { value: 'mmlu_pro', label: 'MMLU Pro' },
    { value: 'mmmu_pro', label: 'MMMU Pro' },
    { value: 'ifbench', label: 'IFBench' },
    { value: 'math_index', label: 'Math Index' },
    { value: 'coding_index', label: 'Coding Index' },
    { value: 'agentic_index', label: 'Agentic Index' },
    { value: 'livecodebench', label: 'LiveCodeBench' },
    { value: 'scicode', label: 'SciCode' },
    { value: 'aime', label: 'AIME' },
    { value: 'aime25', label: 'AIME 25' },
    { value: 'lab_claimed_aime', label: 'Lab-Claimed AIME' },
    { value: 'lab_claimed_math_500', label: 'Lab-Claimed Math 500' },
    { value: 'lcr', label: 'LCR' },
    { value: 'tau2', label: 'TAU-2' },
    { value: 'terminalbench_hard', label: 'TerminalBench Hard' },
    { value: 'multilingual_aa', label: 'Multilingual AA' }
  ];

  // Helper to get benchmark description for axis
  const getBenchmarkDescription = (axis) => {
    const axisLabel = getAxisLabel(axis);
    return BENCHMARK_DESCRIPTIONS[axisLabel] || null;
  };

  return (
    <div className="bg-white rounded-lg shadow-sm p-6">
      <div className="mb-6">
        <div className="flex gap-4 mb-3">
          <div className="flex-1">
            <label className="block text-sm font-medium text-gray-700 mb-2">X-Axis</label>
            <select
              value={xAxis}
              onChange={(e) => onXAxisChange(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
            >
              {axisOptions.map(opt => (
                <option key={opt.value} value={opt.value} disabled={opt.disabled}>{opt.label}</option>
              ))}
            </select>
          </div>
          <div className="flex-1">
            <label className="block text-sm font-medium text-gray-700 mb-2">Y-Axis</label>
            <select
              value={yAxis}
              onChange={(e) => onYAxisChange(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
            >
              {axisOptions.map(opt => (
                <option key={opt.value} value={opt.value} disabled={opt.disabled}>{opt.label}</option>
              ))}
            </select>
          </div>
        </div>

        {/* Display benchmark descriptions when selected */}
        {(getBenchmarkDescription(xAxis) || getBenchmarkDescription(yAxis)) && (
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm">
            <div className="flex items-start gap-2">
              <Info className="w-4 h-4 text-blue-600 mt-0.5 flex-shrink-0" />
              <div className="space-y-2">
                {getBenchmarkDescription(xAxis) && (
                  <div>
                    <span className="font-semibold text-blue-900">{getAxisLabel(xAxis)}:</span>
                    <span className="text-blue-800 ml-1">{getBenchmarkDescription(xAxis)}</span>
                  </div>
                )}
                {getBenchmarkDescription(yAxis) && (
                  <div>
                    <span className="font-semibold text-blue-900">{getAxisLabel(yAxis)}:</span>
                    <span className="text-blue-800 ml-1">{getBenchmarkDescription(yAxis)}</span>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}

        {/* Controls */}
        <div className="flex items-end gap-2 mt-3">
          <label className="flex items-center gap-2 px-4 py-2 bg-gray-100 rounded-lg cursor-pointer hover:bg-gray-200">
            <input
              type="checkbox"
              checked={showLabels}
              onChange={(e) => setShowLabels(e.target.checked)}
              className="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
            />
            <span className="text-sm text-gray-700">Show Labels</span>
          </label>
          <div className="flex items-center gap-2 px-3 py-2 bg-gray-100 rounded-lg">
            <button
              onClick={() => setZoomLevel(Math.max(0.5, zoomLevel - 0.25))}
              className="px-2 py-1 bg-white rounded hover:bg-gray-200 text-gray-700 font-bold"
              title="Zoom Out"
            >
              âˆ’
            </button>
            <span className="text-sm text-gray-700 min-w-[3rem] text-center">{(zoomLevel * 100).toFixed(0)}%</span>
            <button
              onClick={() => setZoomLevel(Math.min(3, zoomLevel + 0.25))}
              className="px-2 py-1 bg-white rounded hover:bg-gray-200 text-gray-700 font-bold"
              title="Zoom In"
            >
              +
            </button>
          </div>
        </div>
      </div>

      <div className="relative" style={{ width: '100%', overflowX: 'auto' }}>
        <svg width={width} height={height} className="border border-gray-200 rounded">
          {/* Grid lines */}
          <g>
            {[0, 0.25, 0.5, 0.75, 1].map(t => {
              const x = padding + t * plotWidth;
              const y = height - padding - t * plotHeight;
              return (
                <g key={t}>
                  <line x1={x} y1={height - padding} x2={x} y2={padding} stroke="#e5e7eb" strokeWidth="1" />
                  <line x1={padding} y1={y} x2={width - padding} y2={y} stroke="#e5e7eb" strokeWidth="1" />
                </g>
              );
            })}
          </g>

          {/* Axes */}
          <line x1={padding} y1={height - padding} x2={width - padding} y2={height - padding} stroke="#374151" strokeWidth="2" />
          <line x1={padding} y1={padding} x2={padding} y2={height - padding} stroke="#374151" strokeWidth="2" />

          {/* Axis labels */}
          <text x={width / 2} y={height - 10} textAnchor="middle" className="text-sm fill-gray-700">{getAxisLabel(xAxis)}</text>
          <text x={20} y={height / 2} textAnchor="middle" transform={`rotate(-90, 20, ${height/2})`} className="text-sm fill-gray-700">{getAxisLabel(yAxis)}</text>

          {/* Tick labels */}
          {[0, 0.5, 1].map(t => {
            const xVal = xMin + t * (xMax - xMin);
            const yVal = yMin + t * (yMax - yMin);
            const x = padding + t * plotWidth;
            const y = height - padding - t * plotHeight;
            return (
              <g key={t}>
                <text x={x} y={height - padding + 20} textAnchor="middle" className="text-xs fill-gray-600">{formatValue(xVal, xAxis)}</text>
                <text x={padding - 10} y={y} textAnchor="end" className="text-xs fill-gray-600">{formatValue(yVal, yAxis)}</text>
              </g>
            );
          })}

          {/* Data points */}
          {plotData.map(({ model, x, y }) => {
            const cx = scaleX(x);
            const cy = scaleY(y);
            return (
              <g key={model.id}>
                <circle
                  cx={cx}
                  cy={cy}
                  r="6"
                  fill="#3b82f6"
                  stroke="#1e40af"
                  strokeWidth="2"
                  className="cursor-pointer hover:fill-blue-700 transition-colors"
                  onMouseEnter={(e) => {
                    setHoveredModel(model);
                    // Get mouse position for smart tooltip positioning
                    const svg = e.currentTarget.ownerSVGElement;
                    const svgRect = svg.getBoundingClientRect();
                    setTooltipPos({
                      mouseX: e.clientX - svgRect.left,
                      mouseY: e.clientY - svgRect.top,
                      svgWidth: svgRect.width,
                      svgHeight: svgRect.height
                    });
                  }}
                  onMouseLeave={() => setHoveredModel(null)}
                />
                {showLabels && (
                  <text
                    x={cx + 10}
                    y={cy + 4}
                    className="text-xs fill-gray-700 pointer-events-none"
                    style={{ fontSize: '10px' }}
                  >
                    {model.id}
                  </text>
                )}
              </g>
            );
          })}
        </svg>

        {/* Enhanced Tooltip - positioned relative to SVG */}
        {hoveredModel && (() => {
          // Smart positioning: keep tooltip within bounds
          const tooltipWidth = 320; // estimated max width
          const tooltipHeight = 250; // estimated max height
          const offset = 15; // distance from cursor

          let left = tooltipPos.mouseX;
          let top = tooltipPos.mouseY;
          let translateX = '0';
          let translateY = '-100%';

          // Check horizontal bounds
          if (left + tooltipWidth + offset > tooltipPos.svgWidth) {
            // Not enough space on right, position to left
            translateX = '-100%';
            left = left - offset;
          } else {
            // Position to right
            left = left + offset;
          }

          // Check vertical bounds
          if (top - tooltipHeight - offset < 0) {
            // Not enough space above, position below
            translateY = '0';
            top = top + offset;
          } else {
            // Position above
            top = top - offset;
          }

          return (
            <div
              className="absolute bg-gray-900 text-white px-4 py-3 rounded-lg shadow-xl text-sm z-50 max-w-sm pointer-events-auto"
              style={{
                left: `${left}px`,
                top: `${top}px`,
                transform: `translate(${translateX}, ${translateY})`
              }}
            >
        })()}
            <div className="font-bold mb-2 text-base flex items-center justify-between gap-2">
              <span>{hoveredModel.name}</span>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  navigator.clipboard.writeText(hoveredModel.id);
                }}
                className="p-1 hover:bg-gray-700 rounded transition-colors flex-shrink-0"
                title="Copy model ID"
              >
                <Copy className="w-4 h-4 text-gray-300 hover:text-white" />
              </button>
            </div>
            <div className="text-xs space-y-1.5">
              <div className="grid grid-cols-2 gap-x-3">
                <span className="text-gray-400">ID:</span>
                <span className="text-gray-200 font-mono text-xs">{hoveredModel.id}</span>
              </div>
              <div className="grid grid-cols-2 gap-x-3">
                <span className="text-gray-400">{getAxisLabel(xAxis)}:</span>
                <span className="text-white font-semibold">{formatValue(getAxisValue(hoveredModel, xAxis), xAxis)}</span>
              </div>
              <div className="grid grid-cols-2 gap-x-3">
                <span className="text-gray-400">{getAxisLabel(yAxis)}:</span>
                <span className="text-white font-semibold">{formatValue(getAxisValue(hoveredModel, yAxis), yAxis)}</span>
              </div>
              <div className="pt-2 mt-2 border-t border-gray-700 space-y-1">
                <div className="grid grid-cols-2 gap-x-3">
                  <span className="text-gray-400">Input Price:</span>
                  <span className="text-green-400">{formatPrice(hoveredModel.pricing.prompt)}</span>
                </div>
                <div className="grid grid-cols-2 gap-x-3">
                  <span className="text-gray-400">Output Price:</span>
                  <span className="text-green-400">{formatPrice(hoveredModel.pricing.completion)}</span>
                </div>
                <div className="grid grid-cols-2 gap-x-3">
                  <span className="text-gray-400">Context:</span>
                  <span className="text-blue-400">{hoveredModel.context_length >= 1000000 ? `${(hoveredModel.context_length/1000000).toFixed(1)}M` : `${(hoveredModel.context_length/1000).toFixed(0)}K`}</span>
                </div>
              </div>
            </div>
          </div>
          );
        })()}
      </div>

      <div className="mt-4 text-sm text-gray-500 text-center">
        Showing {plotData.length} models with data for both axes
      </div>
    </div>
  );
};

const HeatmapView = ({ models, detailedStats, xAxis, yAxis, colorAxis, onXAxisChange, onYAxisChange, onColorAxisChange, formatPrice, modelToAaRowMap }) => {
  const [hoveredCell, setHoveredCell] = useState(null);
  const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
  const [numBins, setNumBins] = useState(30); // Number of bins per axis

  const getAxisValue = (model, axis) => {
    const stats = detailedStats[model.id];
    const aaRow = modelToAaRowMap?.get(model.id);

    switch(axis) {
      case 'latency':
        return stats?.stats?.live_latency || stats?.live_latency ||
               stats?.stats?.p50_latency || stats?.p50_latency || null;
      case 'throughput':
        return stats?.stats?.live_throughput || stats?.live_throughput ||
               stats?.stats?.p50_throughput || stats?.p50_throughput || null;
      case 'prompt_price':
        return parseFloat(model.pricing.prompt);
      case 'completion_price':
        return parseFloat(model.pricing.completion);
      case 'context_length':
        return model.context_length || null;
      case 'request_count':
        return stats?.stats?.request_count || null;
      // AA Benchmark metrics
      case 'intelligence_index':
        return aaRow?.['Intelligence Index'] || null;
      case 'estimated_intelligence_index':
        return aaRow?.['Estimated Intelligence Index'] || null;
      case 'intelligence_index_per_m_output_tokens':
        return aaRow?.['Intelligence Index per 1M Output Tokens'] || null;
      case 'gpqa':
        return aaRow?.['GPQA'] || null;
      case 'hle':
        return aaRow?.['HLE'] || null;
      case 'humaneval':
        return aaRow?.['HumanEval'] || null;
      case 'math_500':
        return aaRow?.['Math 500'] || null;
      case 'mmlu_pro':
        return aaRow?.['MMLU Pro'] || null;
      case 'mmmu_pro':
        return aaRow?.['MMMU Pro'] || null;
      case 'ifbench':
        return aaRow?.['IFBench'] || null;
      case 'math_index':
        return aaRow?.['Math Index'] || null;
      case 'coding_index':
        return aaRow?.['Coding Index'] || null;
      case 'agentic_index':
        return aaRow?.['Agentic Index'] || null;
      case 'livecodebench':
        return aaRow?.['LiveCodeBench'] || null;
      case 'scicode':
        return aaRow?.['SciCode'] || null;
      case 'aime':
        return aaRow?.['AIME'] || null;
      case 'aime25':
        return aaRow?.['AIME 25'] || null;
      case 'lab_claimed_aime':
        return aaRow?.['Lab-Claimed AIME'] || null;
      case 'lab_claimed_math_500':
        return aaRow?.['Lab-Claimed Math 500'] || null;
      case 'lcr':
        return aaRow?.['LCR'] || null;
      case 'tau2':
        return aaRow?.['TAU-2'] || null;
      case 'terminalbench_hard':
        return aaRow?.['TerminalBench Hard'] || null;
      case 'multilingual_aa':
        return aaRow?.['Multilingual AA'] || null;
      default:
        return null;
    }
  };

  const getAxisLabel = (axis) => {
    switch(axis) {
      case 'latency': return 'Latency (ms)';
      case 'throughput': return 'Throughput (tok/s)';
      case 'prompt_price': return 'Input Price ($)';
      case 'completion_price': return 'Output Price ($)';
      case 'context_length': return 'Context Length';
      case 'request_count': return 'Request Count';
      case 'intelligence_index': return 'Intelligence Index';
      case 'estimated_intelligence_index': return 'Estimated Intelligence Index';
      case 'intelligence_index_per_m_output_tokens': return 'Intelligence Index per 1M Output Tokens';
      case 'gpqa': return 'GPQA Score';
      case 'hle': return 'HLE Score';
      case 'humaneval': return 'HumanEval Score';
      case 'math_500': return 'Math 500 Score';
      case 'mmlu_pro': return 'MMLU Pro Score';
      case 'mmmu_pro': return 'MMMU Pro Score';
      case 'ifbench': return 'IFBench Score';
      case 'math_index': return 'Math Index';
      case 'coding_index': return 'Coding Index';
      case 'agentic_index': return 'Agentic Index';
      case 'livecodebench': return 'LiveCodeBench Score';
      case 'scicode': return 'SciCode Score';
      case 'aime': return 'AIME Score';
      case 'aime25': return 'AIME 25 Score';
      case 'lab_claimed_aime': return 'Lab-Claimed AIME';
      case 'lab_claimed_math_500': return 'Lab-Claimed Math 500';
      case 'lcr': return 'LCR';
      case 'tau2': return 'TAU-2';
      case 'terminalbench_hard': return 'TerminalBench Hard';
      case 'multilingual_aa': return 'Multilingual AA';
      default: return axis;
    }
  };

  const formatValue = (val, axis) => {
    if (val === null || val === undefined) return 'N/A';
    if (axis.includes('price')) return formatPrice(val);
    if (axis === 'latency') return `${val.toFixed(0)}ms`;
    if (axis === 'throughput') return `${val.toFixed(1)} tok/s`;
    if (axis === 'context_length') return val >= 1000000 ? `${(val/1000000).toFixed(1)}M` : `${(val/1000).toFixed(0)}K`;
    if (axis === 'request_count') return val.toLocaleString();
  if (axis === 'intelligence_index' || axis === 'estimated_intelligence_index' || axis === 'math_index' || axis === 'coding_index' || axis === 'agentic_index') {
    return val.toFixed(1);
  }
  if (['gpqa','hle','humaneval','math_500','mmlu_pro','mmmu_pro','ifbench','livecodebench','scicode','aime','aime25','lcr','tau2','terminalbench_hard','multilingual_aa'].includes(axis)) {
    return val < 2 ? `${(val * 100).toFixed(1)}%` : val.toFixed(1);
  }
    return val.toFixed(2);
  };

  const axisOptions = [
    { value: 'latency', label: 'Latency' },
    { value: 'throughput', label: 'Throughput' },
    { value: 'prompt_price', label: 'Input Price' },
    { value: 'completion_price', label: 'Output Price' },
    { value: 'context_length', label: 'Context Length' },
    { value: 'request_count', label: 'Request Count' },
    { value: '---', label: '--- AA Benchmarks ---', disabled: true },
    { value: 'intelligence_index', label: 'Intelligence Index' },
    { value: 'estimated_intelligence_index', label: 'Estimated Intelligence Index' },
    { value: 'intelligence_index_per_m_output_tokens', label: 'Intelligence per $ (1M out)' },
    { value: 'gpqa', label: 'GPQA' },
    { value: 'hle', label: 'HLE' },
    { value: 'humaneval', label: 'HumanEval' },
    { value: 'math_500', label: 'Math 500' },
    { value: 'mmlu_pro', label: 'MMLU Pro' },
    { value: 'mmmu_pro', label: 'MMMU Pro' },
    { value: 'ifbench', label: 'IFBench' },
    { value: 'math_index', label: 'Math Index' },
    { value: 'coding_index', label: 'Coding Index' },
    { value: 'agentic_index', label: 'Agentic Index' },
    { value: 'livecodebench', label: 'LiveCodeBench' },
    { value: 'scicode', label: 'SciCode' },
    { value: 'aime', label: 'AIME' },
    { value: 'aime25', label: 'AIME 25' },
    { value: 'lab_claimed_aime', label: 'Lab-Claimed AIME' },
    { value: 'lab_claimed_math_500', label: 'Lab-Claimed Math 500' },
    { value: 'lcr', label: 'LCR' },
    { value: 'tau2', label: 'TAU-2' },
    { value: 'terminalbench_hard', label: 'TerminalBench Hard' },
    { value: 'multilingual_aa', label: 'Multilingual AA' }
  ];

  // Filter models that have all three values
  const validModels = models.filter(model => {
    const x = getAxisValue(model, xAxis);
    const y = getAxisValue(model, yAxis);
    const c = getAxisValue(model, colorAxis);
    return x !== null && y !== null && c !== null && !isNaN(x) && !isNaN(y) && !isNaN(c);
  });

  if (validModels.length === 0) {
    return (
      <div className="bg-white rounded-lg shadow-sm p-8 text-center">
        <p className="text-gray-500">No data available for the selected axes. Try loading stats first or selecting different metrics.</p>
      </div>
    );
  }

  // Get data ranges for binning
  const xValues = validModels.map(m => getAxisValue(m, xAxis));
  const yValues = validModels.map(m => getAxisValue(m, yAxis));
  const colorValues = validModels.map(m => getAxisValue(m, colorAxis));

  const xMin = Math.min(...xValues);
  const xMax = Math.max(...xValues);
  const yMin = Math.min(...yValues);
  const yMax = Math.max(...yValues);
  const colorMin = Math.min(...colorValues);
  const colorMax = Math.max(...colorValues);

  // Create adaptive bins based on data range
  const createAdaptiveBins = (min, max, targetNumBins) => {
    const range = max - min;
    if (range === 0) return [min]; // Handle case where all values are the same

    // Calculate bin size to get approximately targetNumBins bins
    const binSize = range / targetNumBins;

    const bins = [];
    for (let i = 0; i <= targetNumBins; i++) {
      bins.push(min + i * binSize);
    }
    return bins;
  };

  const xBins = createAdaptiveBins(xMin, xMax, numBins);
  const yBins = createAdaptiveBins(yMin, yMax, numBins);
  const xBinSize = xBins.length > 1 ? xBins[1] - xBins[0] : 1;
  const yBinSize = yBins.length > 1 ? yBins[1] - yBins[0] : 1;

  // Bin the data
  const heatmapData = {};
  validModels.forEach(model => {
    const x = getAxisValue(model, xAxis);
    const y = getAxisValue(model, yAxis);
    const c = getAxisValue(model, colorAxis);

    // Find the bin for x and y
    let xBinIdx = -1;
    let yBinIdx = -1;

    for (let i = 0; i < xBins.length - 1; i++) {
      if (x >= xBins[i] && x < xBins[i + 1]) {
        xBinIdx = i;
        break;
      }
    }
    // Handle edge case: value equals max
    if (xBinIdx === -1 && x === xMax) {
      xBinIdx = xBins.length - 2;
    }

    for (let i = 0; i < yBins.length - 1; i++) {
      if (y >= yBins[i] && y < yBins[i + 1]) {
        yBinIdx = i;
        break;
      }
    }
    // Handle edge case: value equals max
    if (yBinIdx === -1 && y === yMax) {
      yBinIdx = yBins.length - 2;
    }

    if (xBinIdx !== -1 && yBinIdx !== -1) {
      const xBin = xBins[xBinIdx];
      const yBin = yBins[yBinIdx];
      const xBinEnd = xBins[xBinIdx + 1];
      const yBinEnd = yBins[yBinIdx + 1];
      const key = `${xBinIdx},${yBinIdx}`;

      if (!heatmapData[key]) {
        heatmapData[key] = { values: [], models: [], xBin, yBin, xBinEnd, yBinEnd, xBinIdx, yBinIdx };
      }
      heatmapData[key].values.push(c);
      heatmapData[key].models.push(model);
    }
  });

  // Calculate average color value for each cell
  Object.keys(heatmapData).forEach(key => {
    const cell = heatmapData[key];
    cell.avgColor = cell.values.reduce((sum, v) => sum + v, 0) / cell.values.length;
  });

  // Color scale function
  const getColor = (value) => {
    const normalized = (value - colorMin) / (colorMax - colorMin);
    // Use a gradient from blue (low) to red (high)
    const r = Math.round(255 * normalized);
    const b = Math.round(255 * (1 - normalized));
    return `rgb(${r}, 100, ${b})`;
  };

  const cellSize = 40;
  const padding = 80;
  const width = xBins.length * cellSize + 2 * padding;
  const height = yBins.length * cellSize + 2 * padding;

  return (
    <div className="bg-white rounded-lg shadow-sm p-6">
      <div className="mb-6">
        <div className="grid grid-cols-3 gap-4 mb-3">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">X-Axis (Binned)</label>
            <select
              value={xAxis}
              onChange={(e) => onXAxisChange(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
            >
              {axisOptions.map(opt => (
                <option key={opt.value} value={opt.value} disabled={opt.disabled}>{opt.label}</option>
              ))}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Y-Axis (Binned)</label>
            <select
              value={yAxis}
              onChange={(e) => onYAxisChange(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
            >
              {axisOptions.map(opt => (
                <option key={opt.value} value={opt.value} disabled={opt.disabled}>{opt.label}</option>
              ))}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Color (Continuous)</label>
            <select
              value={colorAxis}
              onChange={(e) => onColorAxisChange(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
            >
              {axisOptions.map(opt => (
                <option key={opt.value} value={opt.value} disabled={opt.disabled}>{opt.label}</option>
              ))}
            </select>
          </div>
        </div>

        <div className="flex items-center gap-4">
          <label className="text-sm font-medium text-gray-700">Bins per axis:</label>
          <input
            type="range"
            min="10"
            max="100"
            value={numBins}
            onChange={(e) => setNumBins(parseInt(e.target.value))}
            className="w-48"
          />
          <span className="text-sm text-gray-600 min-w-[3rem]">{numBins}</span>
          <span className="text-xs text-gray-500">More bins = finer granularity, larger heatmap</span>
        </div>
      </div>

      <div className="relative overflow-auto" id="heatmap-container">
        <svg width={width} height={height} className="border border-gray-200 rounded">
          {/* Draw heatmap cells */}
          {Object.values(heatmapData).map((cell, idx) => {
            const x = padding + cell.xBinIdx * cellSize;
            const y = height - padding - (cell.yBinIdx + 1) * cellSize;

            return (
              <rect
                key={idx}
                x={x}
                y={y}
                width={cellSize}
                height={cellSize}
                fill={getColor(cell.avgColor)}
                stroke="#fff"
                strokeWidth="1"
                className="cursor-pointer hover:opacity-80 transition-opacity"
                onMouseEnter={(e) => {
                  setHoveredCell(cell);
                  // Get mouse position relative to the container for smart positioning
                  const container = document.getElementById('heatmap-container');
                  const rect = container.getBoundingClientRect();
                  setTooltipPos({
                    mouseX: e.clientX - rect.left,
                    mouseY: e.clientY - rect.top,
                    containerWidth: rect.width,
                    containerHeight: rect.height
                  });
                }}
                onMouseLeave={() => setHoveredCell(null)}
              />
            );
          })}

          {/* Axes */}
          <line x1={padding} y1={height - padding} x2={width - padding} y2={height - padding} stroke="#374151" strokeWidth="2" />
          <line x1={padding} y1={padding} x2={padding} y2={height - padding} stroke="#374151" strokeWidth="2" />

          {/* Axis labels */}
          <text x={width / 2} y={height - 10} textAnchor="middle" className="text-sm fill-gray-700">{getAxisLabel(xAxis)}</text>
          <text x={20} y={height / 2} textAnchor="middle" transform={`rotate(-90, 20, ${height/2})`} className="text-sm fill-gray-700">{getAxisLabel(yAxis)}</text>

          {/* Tick labels - show a sample */}
          {xBins.filter((_, i) => i % Math.max(1, Math.floor(xBins.length / 10)) === 0 && i < xBins.length - 1).map((bin, idx) => {
            const binIdx = xBins.indexOf(bin);
            const x = padding + binIdx * cellSize + cellSize / 2;
            return (
              <text key={idx} x={x} y={height - padding + 20} textAnchor="middle" className="text-xs fill-gray-600">
                {formatValue(bin, xAxis)}
              </text>
            );
          })}
          {yBins.filter((_, i) => i % Math.max(1, Math.floor(yBins.length / 10)) === 0 && i < yBins.length - 1).map((bin, idx) => {
            const binIdx = yBins.indexOf(bin);
            const y = height - padding - binIdx * cellSize - cellSize / 2;
            return (
              <text key={idx} x={padding - 10} y={y} textAnchor="end" className="text-xs fill-gray-600">
                {formatValue(bin, yAxis)}
              </text>
            );
          })}
        </svg>

        {/* Tooltip - positioned next to hovered cell */}
        {hoveredCell && (() => {
          // Smart positioning: keep tooltip within bounds
          const tooltipWidth = 350; // estimated max width
          const tooltipHeight = 150; // estimated max height
          const offset = 15; // distance from cursor

          let left = tooltipPos.mouseX;
          let top = tooltipPos.mouseY;
          let translateX = '0';
          let translateY = '-50%'; // center vertically by default

          // Check horizontal bounds
          if (left + tooltipWidth + offset > tooltipPos.containerWidth) {
            // Not enough space on right, position to left
            translateX = '-100%';
            left = left - offset;
          } else {
            // Position to right
            left = left + offset;
          }

          // Check vertical bounds
          if (top - tooltipHeight / 2 < 0) {
            // Would overflow top, align to top
            translateY = '0';
            top = 10;
          } else if (top + tooltipHeight / 2 > tooltipPos.containerHeight) {
            // Would overflow bottom, align to bottom
            translateY = '-100%';
            top = tooltipPos.containerHeight - 10;
          }

          return (
            <div
              className="absolute bg-gray-900 text-white rounded-lg p-3 text-sm z-50 max-w-sm pointer-events-none shadow-xl"
              style={{
                left: `${left}px`,
                top: `${top}px`,
                transform: `translate(${translateX}, ${translateY})`
              }}
            >
        })()}
            <div className="font-semibold mb-2">
              {getAxisLabel(xAxis)}: {formatValue(hoveredCell.xBin, xAxis)} - {formatValue(hoveredCell.xBinEnd, xAxis)}
              <br />
              {getAxisLabel(yAxis)}: {formatValue(hoveredCell.yBin, yAxis)} - {formatValue(hoveredCell.yBinEnd, yAxis)}
            </div>
            <div className="text-gray-300">
              Models in this cell: {hoveredCell.models.length}
              <br />
              Average {getAxisLabel(colorAxis)}: {formatValue(hoveredCell.avgColor, colorAxis)}
            </div>
            <div className="mt-2 text-xs text-gray-400">
              {hoveredCell.models.slice(0, 5).map(m => m.id).join(', ')}
              {hoveredCell.models.length > 5 && `, +${hoveredCell.models.length - 5} more`}
            </div>
          </div>
          );
        })()}
      </div>

      {/* Color legend */}
      <div className="mt-4 flex items-center gap-4">
        <span className="text-sm font-medium text-gray-700">{getAxisLabel(colorAxis)}:</span>
        <div className="flex items-center gap-2">
          <span className="text-xs text-gray-600">{formatValue(colorMin, colorAxis)}</span>
          <div className="w-64 h-6 rounded" style={{
            background: `linear-gradient(to right, rgb(0, 100, 255), rgb(255, 100, 0))`
          }}></div>
          <span className="text-xs text-gray-600">{formatValue(colorMax, colorAxis)}</span>
        </div>
      </div>

      <div className="mt-4 text-sm text-gray-500 text-center">
        Showing {validModels.length} models â€¢ {Object.keys(heatmapData).length} cells with data
      </div>
    </div>
  );
};

const MappingView = ({ models, mapping, setMapping, fetchAALeaderboard, aaLoading, aaError }) => {
  const [search, setSearch] = useState('');

  const modelOptions = useMemo(() => {
    const opts = models.map(m => ({ id: m.id, label: `${m.name} â€” ${m.id}` }));
    return opts.sort((a, b) => a.label.localeCompare(b.label));
  }, [models]);

  const filteredMapping = useMemo(() => {
    const q = search.trim().toLowerCase();
    if (!q) return mapping;
    return mapping.filter(item => {
      const alias = item.alias.toLowerCase();
      const target = item.targetId ? item.targetId.toLowerCase() : '';
      return alias.includes(q) || target.includes(q);
    });
  }, [mapping, search]);

  const handleChange = (alias, newId) => {
    setMapping(prev => prev.map(it => it.alias === alias ? { ...it, targetId: newId || null } : it));
  };

  const mappedCount = mapping.filter(it => !!it.targetId).length;

  const resetDefaults = () => setMapping(INITIAL_AA_MAPPING.map(x => ({ ...x })));
  const clearAll = () => setMapping(mapping.map(x => ({ ...x, targetId: null })));
  const exportJson = () => {
    const obj = {};
    mapping.forEach(it => { if (it.targetId) obj[it.alias] = it.targetId; });
    const text = JSON.stringify(obj, null, 2);
    const blob = new Blob([text], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `aa-mapping-${new Date().toISOString().split('T')[0]}.json`;
    a.click(); URL.revokeObjectURL(url);
  };

  return (
    <div className="bg-white rounded-lg shadow-sm p-4">
      <div className="flex flex-col md:flex-row md:items-center gap-3 md:gap-4 mb-4">
        <div className="flex-1 relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
          <input
            type="text"
            placeholder="Search aliases or IDs..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
        </div>
        <div className="flex items-center gap-2 text-sm text-gray-600">
          <span className="px-2 py-1 bg-blue-50 text-blue-700 rounded">{mappedCount} mapped</span>
          <button onClick={resetDefaults} className="px-3 py-2 border rounded hover:bg-gray-50">Reset to defaults</button>
          <button onClick={clearAll} className="px-3 py-2 border rounded hover:bg-gray-50">Clear all</button>
          <button onClick={exportJson} className="px-3 py-2 border rounded hover:bg-gray-50 flex items-center gap-2">
            <Download className="w-4 h-4" /> Export JSON
          </button>
          <button onClick={fetchAALeaderboard} disabled={aaLoading} className="px-3 py-2 border rounded hover:bg-gray-50 flex items-center gap-2 disabled:bg-gray-200 disabled:cursor-not-allowed">
            <RefreshCw className={`w-4 h-4 ${aaLoading ? 'animate-spin' : ''}`} /> {aaLoading ? 'Fetching...' : 'Fetch AA Data'}
          </button>
        </div>
      </div>

      {aaError && (
        <div className="bg-red-50 border-l-4 border-red-400 p-4 my-4">
            <div className="text-sm text-red-700">
                <strong>Error:</strong> {aaError}
            </div>
        </div>
      )}

      <div className="text-sm text-gray-600 mb-3">
        This maps Set 1 aliases to OpenRouter models (Set 2). Changes auto-save to your browser.
      </div>

      <div className="overflow-x-auto border border-gray-200 rounded-lg">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Set 1 Alias</th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Mapped Set 2 (OpenRouter ID)</th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Certainty</th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-100">
            {filteredMapping.map(item => (
              <tr key={item.alias}>
                <td className="px-4 py-3">
                  <div className="font-medium text-gray-900">{item.alias}</div>
                </td>
                <td className="px-4 py-3">
                  <select
                    value={item.targetId || ''}
                    onChange={(e) => handleChange(item.alias, e.target.value)}
                    className="w-full max-w-xl px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="">Not mapped / Unknown</option>
                    {modelOptions.map(opt => (
                      <option key={opt.id} value={opt.id}>{opt.label}</option>
                    ))}
                  </select>
                </td>
                <td className="px-4 py-3">
                  <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${
                    item.certainty === 'High' ? 'bg-green-100 text-green-800' :
                    item.certainty === 'Medium' ? 'bg-yellow-100 text-yellow-800' :
                    'bg-gray-100 text-gray-700'
                  }`}>
                    {item.certainty || '-'}
                  </span>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<ModelsDashboard />);
    </script>
</body>
</html>
